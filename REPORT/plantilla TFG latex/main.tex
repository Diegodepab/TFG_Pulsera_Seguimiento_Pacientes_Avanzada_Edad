\documentclass[12pt, a4paper]{article}

%% Preamble
\usepackage{umatfgspanish}
\usepackage{blindtext}
\graphicspath{ {./images/} }

%% Packages using specific for this project
\usepackage{longtable}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{xurl}
\usepackage{textcomp} % para \textdegree y \texteuro
\usepackage[T1]{fontenc}


%— Coloreado con minted y cajas con tcolorbox —
\usepackage{tcolorbox}
\tcbuselibrary{minted,skins}

% Caja genérica para comandos de terminal
\newtcolorbox{Terminal}[2][]{%
	listing only,
	minted language=bash,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=black!75,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

% Entorno para código Python
\newtcolorbox{PythonCode}[2][]{%
	listing only,
	minted language=python,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=blue!50!black,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

% Entorno para código Java
\newtcolorbox{JavaCode}[2][]{%
	listing only,
	minted language=java,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=red!50!black,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

\begin{document}

\includepdf[noautoscale=true, width=\paperwidth]{cover.pdf}

\includepdf[noautoscale=true, width=\paperwidth]{title.pdf}


%% Abstract
\begin{abstract}
    
	El envejecimiento progresivo de la población exige soluciones de monitorización remota para mitigar uno de los principales riesgos a los que se enfrentan las personas mayores: las caídas y las lesiones relacionadas con ellas. Este Trabajo de Fin de Grado (TFG) presenta el diseño e implementación de un sistema completo de telemonitorización compuesto por un prototipo de pulsera y una plataforma de telemedicina complementaria. La pulsera, construida en torno a un módulo ESP32 (LilyGO TTGO T-Display) y equipada con un sensor óptico MAX30102 y un sensor de movimiento MPU-6050, registra la frecuencia cardíaca, la saturación de oxígeno en sangre (SpO\textsubscript{2}), el recuento de pasos y detecta las caídas mediante algoritmos basados en umbrales. Los datos se transmiten a través de MQTT a un broker; la plataforma de telemedicina aprovecha esta información para proporcionar un sistema de monitorización de pacientes con múltiples herramientas (gestión de pacientes, patologías asociadas, sistemas de alarmas, chat entre usuarios, etc.). Aunque los sensores empleados no son dispositivos clínicos certificados, el proyecto demuestra la integración práctica de hardware, algoritmos de procesamiento de señales y software para permitir la monitorización remota de pacientes.
	
	
	
	{\bfseries\large Palabras clave:} Telemedicina, Plataforma médica, ESP32, Ingeniería web

\end{abstract}

%% Resumen
\section*{Abstract}

	The progressive ageing of the population demands remote monitoring solutions to mitigate one of the main risks faced by older adults: falls and related injuries. This Final Degree Project (Trabajo de Fin de Grado, TFG) presents the designand implementation of a complete telemonitoring system composed of a wristband prototype and an accompanying telemedicine platform. The wristband, built around an ESP32 module (LilyGO TTGO T-Display) and equipped with a MAX30102 optical sensor and an MPU-6050 motion sensor, records heart rate, blood oxygen saturation (SpO\textsubscript{2}), step counts and detects falls using threshold-based algorithms. Data are transmitted via MQTT to a broker; the telemedicine platform exploits this information to provide a patient monitoring system with multiple tools (patient management, associated pathologies, alarm systems, user-to-user chat, etc.). Although the sensors employed are not certified clinical devices, the project demonstrates the practical integration of hardware, signal-processing algorithms and software to enable end-to-end remote patient monitoring.
	
	{\bfseries\large Keywords:} Telemedicine, Medical platform, ESP32, Web engineering
	

\clearpage
\section*{Agradecimientos}

Apelando a la parte más humana de este trabajo, considero importante dejar constancia de aquellas personas que han sido fundamentales en mi crecimiento personal y acad\'emico durante estos a\~nos de universidad, y cuya influencia ha sido clave en la realizaci\'on de este Trabajo de Fin de Grado.

En primer lugar, quiero agradecer al personal acad\'emico de la universidad que muestra un esfuerzo e interés por ofrecer una formaci\'on de calidad. De forma especial, a mi tutor Cristian Mart\'in, a quien valoro profundamente tanto como docente como por su calidad humana. Junto a \'el profesores como Ismael Navas, Jos\'e Jerez, Rafael Luque, Rafael Larrosa, David Bueno, entre otros. Han contribuido significativamente a mi desarrollo intelectual y personal. Gracias a su dedicaci\'on, hoy reafirmo con alegría la decisi\'on de haber cursado esta carrera.

Tambi\'en quiero expresar mi gratitud a mis compa\~neros. Aunque ser\'ia imposible nombrar a todos, quiero destacar a Alejandro Silva y Mario Pascual, por su constante apoyo, por inspirarme a aspirar a más y por estar siempre presentes en los momentos clave de este recorrido.

En el \'ambito familiar, nada de esto habr\'ia sido posible sin el respaldo incondicional de mis padres y, especialmente, de mi hermano.

Quiero dedicar una menci\'on muy especial a mis abuelos, R\'egulo Depablos y Polia Moros, con quienes he compartido la evoluci\'on de este trabajo semana tras semana, como si ellos mismos fueran los pacientes. Con ellos he vivido la angustia de que un familiar sufra una caída y tener este TFG fue una oportunidad para tenerlos presentes en mi cabeza y darme cuenta de la importancia que tienen.

Finalmente, rindo homenaje a mi t\'ia Mireya Moros, quien falleci\'o este a\~no 2025. Aunque me pesa no haber podido visitarla en mi tierra natal, me reconforta saber que, a trav\'es de llamadas donde hablábamos de este trabajo, mi vida universitaria, etc. Se alegró de que la tuviera tan presente al hacer este trabajo con ella en mente. Y pude disfrutar con ella en sus últimos meses.

\vspace{1em}

Muchas gracias.

\tableofcontents

%% Sections
\section{Introducción}

	\subsection{Motivatión}
    
    El progresivo envejecimiento demográfico subraya la necesidad de soluciones tecnológicas orientadas a las personas mayores. En España, los mayores de 65 años representan actualmente el 20,4\% de la población total, cifra que, según el INE \cite{INE2024}, ascenderá a más del 30\% hacia mediados de siglo. A escala europea, la tendencia es similar: a principios de 2024, más de una quinta parte de la población de la UE tenía 65 o más años \cite{Euro2025}. Este panorama anticipa un incremento sostenido de las enfermedades crónicas y de la dependencia, acentuando la carga asistencial en hogares y centros sanitarios.
    
    Dentro de este colectivo vulnerable, las caídas suponen un grave problema de salud pública. En España viven unos 8,1 millones de personas ancianas, las cuales registran aproximadamente 4,3 millones de caídas al año, la mayoría de ellas en el propio domicilio \cite{Rodriguez2015}. Estudios recientes indican que alrededor de un tercio de los mayores de 65 años sufre al menos una caída anual, proporción que aumenta hasta el 50\% en mayores de 80. Del total de caídas, cerca del 9,3\% causan fracturas y más del 55\% requieren atención médica de urgencia. A nivel mundial, la Organización Mundial de la Salud destaca que las caídas son la segunda causa global de traumatismos accidentales (alrededor de 684 000 fallecimientos anuales) y que 37,3 millones de episodios de caídas exigen atención médica cada año; las tasas de mortalidad más altas corresponden a mayores de 60 años \cite{OMS2021}. Estos datos ilustran la magnitud del problema: las caídas en ancianos no solo comprometen la salud individual, sino que constituyen un reto para el sistema sanitario.
    
    Frente a este escenario, la tecnología \emph{wearable}, elementos como relojes, collares, etc. que se pueden llevar a todas partes, permitiendo monitorización continua y a distancia, surge como una solución prometedora. Funciones como detectar in situ caídas mediante acelerometría y, simultáneamente, registrar valores de interés para el seguimiento y mejora del paciente (frecuencia cardíaca, saturación de oxígenos y nivel de actividad física). De este modo se habilita un soporte permanente. Proyectos recientes respaldan esta aproximación: por ejemplo, La iniciativa privada Seniordomo ofrece un servicio de teleasistencia avanzada mediante wearable y monitoreo constante a través de una plataforma accesible para profesionales y pacientes \cite{seniordomo}. 
    
    El valor de esta tecnología se traduce además en mejoras concretas de calidad de vida. Al aumentar la seguridad del entorno, al sentirse acompañado a través de conexión permanente con familiares o servicios de salud. La persona mayor experimenta mayor tranquilidad y menor aislamiento \cite{Reina2024}, así como, al fomentar la autonomía domiciliaria (permitiendo quedarse más tiempo en casa pese a la fragilidad), se eleva la comodidad y el ánimo del anciano \cite{Reina2024}. Desde el punto de vista sanitario, disponer de registros continuos de datos biomédicos que se comparten con los profesionales facilita la detección temprana de signos de alerta y permite actuar de forma preventiva, asimismo obtener más información del paciente. En conjunto, estas prestaciones tecnológicas apoyan a los cuidadores, aligerando su carga y promoviendo un modelo de atención más proactivo y centrado en la prevención.
    
    El diseño de una pulsera con detección de caídas y monitorización de constantes vitales es una tecnología que cada vez cobrará mayor importancia. Permitirá abordar uno de los principales riesgos de salud en el envejecimiento poblacional, las caídas, reduciendo su impacto clínico y social. Esto, enfocado a la par con la telemedicina, ofreciendo un seguimiento de datos a cualquier paciente en el mundo, abarca una solución para una problemática que abarca cientos de millones de personas mayores alrededor del mundo.

	\subsection{Objetivos}
	
	\subsubsection{Objetivo general}
	Desarrollar un prototipo de pulsera acompañado de una plataforma de telemedicina, que permita el seguimiento remoto de parámetros vitales (frecuencia cardíaca, saturación de oxígeno y actividad física) y la detección de caídas en personas mayores.
	
	\subsubsection{Objetivos específicos}
	\begin{itemize}
		\item Diseñar un prototipo de la pulsera utilizando un microcontrolador, y sensores como pulsímetro, oxímetro, acelerómetro y giroscopio para la medición de constantes vitales y posibles caídas.
		
		\item Desarrollar algoritmos de detección de caídas basados en los datos obtenidos del acelerómetro y giroscopio, mediante la definición de umbrales y patrones que permitan diferenciar caídas.
		
		\item Implementar la plataforma de telemonitoreo:
		\begin{itemize}
			\item \textbf{Back-end (Python):} Servidor capaz de recibir, procesar y almacenar la información de la base de datos (postgreSQL) de manera segura.
			
			\item \textbf{Front-end (Svelte):} Interfaz web intuitiva destinada a médicos y cuidadores, que muestre toda la información necesaria del paciente, patologías, gráficas de evolución de parámetros vitales, notificaciones de alertas y  chat asegurando el mejor seguimiento.
		\end{itemize}
		
		\item Integrar la comunicación Wi-Fi de la pulsera, asegurando un flujo de datos seguro utilizando el protocolo MQTT.
		
		
	\end{itemize}

	
	\subsection{Estructura de la memoria}
	
	La memoria se encuentra dividida en los siguientes capítulos, cada uno de los cuales aborda de manera detallada los aspectos fundamentales del proyecto:
	
	\begin{itemize}
		\item \textbf{Capítulo 1 y 2: Introducción y marco teórico.}  
		En este primer capítulo se presenta el contexto general del Trabajo de Fin de Grado. Se describe la motivación que impulsa el desarrollo de una pulsera para el seguimiento de pacientes mayores, así como los objetivos generales y específicos del proyecto. Además, se incluye un breve análisis de precedentes y estudios relacionados, a su vez se evalúa la viabilidad técnica y económica.
		
		\item \textbf{Capítulo 3: Análisis funcional y técnico.}  
		En este capítulo se definen los requisitos del sistema, tanto funcionales como no funcionales. Se identifican los stakeholders principales y se analizan sus necesidades. Además, se realiza un estudio de riesgos.
		
		\item \textbf{Capítulo 4 y 5: Elección de alternativas y diseño de la pulsera (Hardware).}  
		\begin{itemize}
			\item \emph{Estudio de alternativas:} Se exponen las diferentes opciones de microcontroladores, sensores y baterías disponibles en el mercado que podrían cumplir con los requisitos definidos y se destaca las opciones elegidas.
			\item \emph{Diseño del esquemático:} Se detalla el esquema de la pulsera, señalando conexiones.
			\item \emph{Montaje físico y prototipado:} Se describe el proceso de soldadura y ensamblaje de componentes.  
			\item \emph{Desarrollo de código arduino} Se explica la estructura modular del firmware en lenguaje C++ para Arduino, detallando las tareas principales: inicialización, lectura de sensores, procesamiento de datos para detección de caídas y cálculo de parámetros de frecuencia cardíaca y SpO\textsubscript{2}, gestión de eventos de alerta y comunicación con la plataforma remota.  
			\item \emph{Protocolo MQTT:} Se justifica el uso de MQTT para la comunicación ligera entre la pulsera (cliente MQTT) y el servidor (broker MQTT), describiendo topologías de publicación/suscripción, calidad de servicio (QoS) y estrategias de reconexión ante pérdida de cobertura Wi-Fi.
			\item \emph{Pruebas del dispositivo:} Se muestra en rasgos generales el funcionamiento del prototipo, mostrando los resultados y su comportamiento ante eventos.
		\end{itemize}
		
		\item \textbf{Capítulo 6: Diseño de la base de datos.}
		\begin{itemize}
			\item \emph{Uso de PostgreSQL:} Justificación breve de la elección, modo de empleo y herramientas a usar.
			\item \emph{Información que se desea manejar:} Resumen de familias de datos, desde que tipos de datos se desean tener y como se van a plantear en la base de datos.
			\item \emph{Modelo entidad-relación:} Diagrama lógico con las entidades principales.
		\end{itemize}
		
		\item \textbf{Capítulo 7: Desarrollo de la plataforma web.}  
		\begin{itemize}
			\item \emph{Arquitectura general del sistema:} Se describe la arquitectura cliente-servidor basada en microservicios, incluyendo la configuración de contenedores Docker para cada componente, la integración de Nginx como servidor web y proxy inverso, y el uso de Redis para caché y mensajería en tiempo real.
			\item \emph{Back-end (Python):} Se describen las tecnologías y frameworks elegidos (por ejemplo, FastAPI), la estructura de rutas RESTful, los modelos de datos para PostgreSQL y la lógica para procesar y almacenar las lecturas de la pulsera. También se documenta la implementación de mecanismos de autenticación y autorización para usuarios (médicos, familiares, cuidadores).  
			\item \emph{Front-end (Svelte):} Se explican las decisiones de diseño de la interfaz de usuario, enfocado en la usabilidad para pacientes y personal sanitario. Se incluyen los componentes principales: panel de control con gráficas de evolución de constantes vitales (frecuencia cardíaca, SpO\textsubscript{2}, pasos diarios), lista de alertas en tiempo real y formularios para configuración de umbrales y datos de contacto.  
		\end{itemize}
		
		\item \textbf{Capítulo 8: Conclusiones y perspectivas futuras.}  
		En este capítulo se sintetizan los resultados obtenidos y se valora el grado de cumplimiento de los objetivos planteados al inicio del trabajo. Contiene un resumen ejecutivo de los logros técnicos (prototipo de pulsera, integración con plataforma web, mecanismos de comunicación y persistencia), Además, se presentan las líneas de mejora.
		
		\item \textbf{Apéndice (Manual de uso).}  
		En el Apéndice se incluyen documentos de soporte para el usuario final y el equipo técnico:
		\begin{itemize}
			\item \emph{Manual de usuario del prototipo:} Ejemplo de uso del prototipo hardware, además de principales indicaciones y ejemplos de las funcionalidades.  
			\item \emph{Publicación de mesnajes MQTT desde un ESP32 y configuración de broker} Guía que describe como montar un entorno para manejar el protocolo MQTT en un PC (windows o linux) usando Mosquitto.
			\item \emph{Manual de instalación del entorno de la plataforma:} Pasos detallados para desplegar la plataforma mediante Docker, configuración de variables de entorno.
			\item \emph{Población de la base de datos} Guía para poblar la base de datos mediante un script de profesionales de la salud y pacientes a partir de datos falsos, para probar la plataforma en un entorno de desarrollo.
			\item \emph{Manual de uso de la plataforma web:} Ejemplo de uso de plataforma de telemedicina enfocando en mostrar todas sus rutas,  funciones y utilidades. 
		\end{itemize}
	\end{itemize}
	

\section{Marco teórico}

	Es importante contextualizar y tomar de guía algunos de los proyectos que tienen una relación directa con la idea planteada, al ser una problemática de gran importancia se parte de una base ya explorada.

	\subsection{Ejemplos similares de dispositivos y teleasistencia médica}
	
	Actualmente existen múltiples propuestas para pulseras o equipos de seguimiento de pacientes de avanzada edad, el mayor problema de las soluciones es la dificultad en la globalización de un sistema que pueda ser adaptado a cualquier paciente.
	
	\subsubsection{SeniorDomo}
	
	SeniorDomo ofrece un servicio de teleasistencia avanzada para personas mayores que permite hacer un seguimiento continuo y preventivo. Utiliza un reloj para ofrecer múltiples funciones como detección de situaciones de riesgos (inactividad, pulso anómalo o caídas), botones de ayuda, localización GPS y permite procesar llamadas \cite{seniordomo}.
	
	\subsubsection{Bastón Pauto}
	

	El Bastón Pauto es un dispositivo de ayuda dirigido a personas mayores con patologías como párkinson o deterioro cognitivo. Integra detección de caídas, un botón de emergencia y un sistema de proyección láser de una línea y un punto más vibración en la empuñadura, que facilita la reanudación del paso durante episodios de bloqueo de la marcha. Estas señales sensoriales pueden disminuir el riesgo de caídas y aumentar la autonomía del usuario; además, su compatibilidad con sistemas de teleasistencia permite notificar y monitorizar incidentes de forma remota \cite{Pauto2019}.
	
	\subsubsection{Teleasistencia avanzada en Castilla-La Mancha}
	
	Además de iniciativas privadas también existen ejemplos como la Junta de Comunidades de Castilla-La Mancha que ha implementado un sistema de teleasistencia avanzada que atiende actualmente a más de 81.000 personas. Este sistema incluye dispositivos que detectan riesgos como caídas, incendios o escapes de gas, y utiliza inteligencia artificial para analizar rutinas y detectar alteraciones que puedan indicar situaciones de riesgo \cite{castillalamancha2025}.
	


	\subsection{Sistemas de detección de caídas existentes}


	La detección de caídas en personas mayores es un área de investigación activa, con múltiples enfoques tecnológicos desarrollados para abordar este problema de salud pública. A continuación, se describen algunos de los sistemas más relevantes:
		
	\subsubsection{Sistemas basados en umbrales}

	
	Estos sistemas utilizan acelerómetros para monitorizar los movimientos del usuario y detectar patrones que indiquen una caída. La detección se basa en establecer umbrales específicos de aceleración que, al ser superados, activan una alerta. Por ejemplo, en un TFG de la UCM sobre el desarrollo de un sistema de detección de caídas basado en acelerómetros se evalúa la magnitud máxima del vector de aceleración, calculada como:
	
	\[
	|\mathbf{a}| = \sqrt{a_x^2 + a_y^2 + a_z^2}
	\]
	
	donde \(a_x\), \(a_y\) y \(a_z\) son las componentes de aceleración en los ejes ortogonales X, Y y Z. Según los datos empíricos del estudio, las caídas provocan picos transitorios de aceleración de hasta 12 g, mientras que el valor mínimo de aceleración observado en una caída es de aproximadamente 3 g \cite{bourke2007}. Las actividades de la vida diaria (ADL) raramente superan los 3 g, aunque movimientos bruscos como correr o sentarse rápidamente pueden acercarse a este umbral \cite{kangas2012}. Debido al solapamiento entre los rangos de aceleración de caídas y ADL, el umbral de detección debe ajustarse cuidadosamente a cada paciente para minimizar falsos positivos y garantizar la robustez del algoritmo \cite{ucm2015}.
	
	\subsubsection{Sistemas basados en aprendizaje automático}
	
	El aprendizaje automático permite mejorar la precisión en la detección de caídas al analizar patrones complejos de movimiento. Un sistema desarrollado utiliza datos de sensores como acelerómetros para calcular características que luego son clasificadas por algoritmos como SVM o árboles de decisión, alcanzando una precisión del 96\% en la detección de caídas \cite{lauro2021}.
	
	
	\subsection{Medición de constantes vitales en wearables}
	
	Los dispositivos wearables han evolucionado para incluir sensores que permiten la monitorización continua de constantes vitales, lo cual es especialmente útil en la atención de personas mayores. Algunos de los parámetros comúnmente medidos incluyen:
	
	\begin{itemize}
		\item \textbf{Frecuencia cardíaca:} Utilizando sensores ópticos (fotopletismografía), los wearables pueden medir la frecuencia cardíaca en tiempo real.
		\item \textbf{Saturación de oxígeno (SpO\textsubscript{2}):} A través de sensores similares a los utilizados en pulsioxímetros, se puede estimar la saturación de oxígeno en la sangre.
		\item \textbf{Actividad física:} Los acelerómetros y giroscopios integrados permiten registrar la cantidad y tipo de actividad física realizada por el usuario.
	\end{itemize}
	
	La integración de estos sensores en dispositivos como pulseras inteligentes facilita el seguimiento remoto de la salud de los pacientes, permitiendo intervenciones tempranas y mejorando la calidad de vida de las personas mayores \cite{rodriguez2015}.


\section{Análisis funcional y técnico}
	
	Durante el transcurso de la carrera universitaria Ingeniería de la Salud otorga múltiples herramientas, conocimientos y capacidades para enfrentarse a diversos retos, no obstante de las cualidades más importantes es la correcta aplicación de ingeniería de requisitos.

	La especificación y gestión de requisitos es clave para el éxito de proyectos multidisciplinarios de informática e IoT, al facilitar la comunicación entre stakeholders y mejorar la calidad del sistema final \cite{wiegers, pohl}. Para garantizar especificaciones claras y trazables, se adoptan las buenas prácticas propuestas en IEEE 830–1998 y la norma ISO/IEC/IEEE 29148 \cite{ieee830, iso29148}.
	
		\subsection{Metodología de diseño}
		Para el desarrollo de este proyecto se ha optado por una \emph{metodología de diseño iterativo}, un enfoque cíclico que combina fases sucesivas de análisis, diseño, implementación y evaluación, de forma que cada iteración entrega un módulo funcional susceptible de validación y ajuste temprano \cite{wiegers,iso29148}. Este proceso permite detectar y corregir errores de manera precoz, incorporar cambios en los requisitos con agilidad y entregar incrementos de valor continuo, mejorando la adaptabilidad.
		
		Además, la naturaleza modular de cada iteración fomenta buenas prácticas de ingeniería de software, tales como la alta cohesión y el bajo acoplamiento, al dividir el sistema en componentes independientes que pueden desarrollarse y probarse en paralelo. La retroalimentación al iterar garantiza que el producto evolucione alineado a las necesidades reales, optimizando recursos y asegurando una mayor calidad final \cite{wiegers}.
	
		\subsection{Requisitos}
		
		Un requisito es una condición o capacidad que el sistema debe satisfacer para cubrir las necesidades de usuarios y partes interesadas. Se clasifican en funcionales, describen lo que el sistema debe hacer, y no funcionales, atributos de calidad del sistema \cite{sommerville}.
	
			\subsubsection{Requisitos funcionales}
			
			Los requisitos funcionales definen los servicios y comportamientos que el sistema debe ofrecer para cumplir sus objetivos \cite{ieee830}. En este proyecto, los requisitos se describen mediante los siguientes atributos:
			
			\begin{itemize}
				\item \textbf{ID:} Código único que identifica el requisito (ejemplo RF1).
				\item \textbf{Descripción:} Enunciado breve de la función a realizar.
				\item \textbf{Obligatoriedad:} “Obligatorio” u “Opcional” según prioridad de implementación.
				\item \textbf{Dependencia:} Requisitos previos necesarios para su correcto funcionamiento.
				\item \textbf{Trazabilidad:} Referencia a la sección del documento donde se detalla.
			\end{itemize}

			
			\begin{table}[ht]
				\centering
				\caption{Principales Requisitos Funcionales}
				\begin{tabular}{|p{1.5cm}|p{6cm}|p{2cm}|p{2cm}|p{3cm}|}
					\hline
					\textbf{ID} & \textbf{Descripción} & \textbf{Oblig.} & \textbf{Depend.} \\
					\hline
					RF1 & El usuario podrá registrarse en el sistema (administrador, médico, paciente). & Obligatorio & —    \\
					\hline
					RF2 & Manejo de tokens y credenciales.                       & Obligatorio & RF1 \\
					\hline
					RF3 & Visualización de datos del usuario. & Obligatorio & —    \\
					\hline
					RF4 & Almacenamiento y consulta de datos en la base de datos.         & Obligatorio & - \\
					\hline
					RF6 & Manejo de alertas             & Obligatorio & RF3  \\
					\hline
					RF7 & Mensajería entre los usuarios.                              & Opcional   & RF1 \\
					\hline
					RF8 & Gestión del perfil.               & Opcional & RF1 \\
					\hline
				\end{tabular}
			\end{table}
	
	
	
		\subsubsection{No funcionales}
		
		Los requisitos no funcionales establecen las propiedades de calidad que el sistema debe cumplir \cite{ieee830}.
		
		\begin{table}[ht]
			\centering
			\caption{Principales requisitos no funcionales}
			\label{tab:req-no-funcionales}
			\begin{tabular}{|c|p{6cm}|c|c|c|}
				\hline
				\textbf{ID} & \textbf{Descripción} & \textbf{Oblig.} & \textbf{Depend.}  \\
				\hline
				RNF1 & Autonomía entre pulsera, base de datos y plataforma. & Obligatorio & RF4 \\
				\hline
				RNF2 & Implementación de lógica modular facilitando sustitución de piezas. & Obligatorio & -  \\
				\hline
				RNF3 & Simplicidad en la plataforma. & Opcional & RF3\\
				\hline
				RNF4 & Cifrado de datos personales. & Obligatorio & RF2, RF4 \\
				\hline
			\end{tabular}
		\end{table}

	
		\subsection{Análisis de riesgo}
		Al implementar un proyecto multidisciplinario con hardware, firmware y plataforma web, existen riesgos clave que deben gestionarse para asegurar el éxito. El siguiente cuadro resume los principales riesgos, su probabilidad e impacto, y las estrategias de mitigación.
		
		\begin{table}[ht]
			\centering
			\caption{Análisis de Riesgos del TFG}
			\begin{tabular}{|p{1cm}|p{5cm}|p{3cm}|p{6cm}|}
				\hline
				\textbf{Id} & \textbf{Descripción} & \textbf{Probabilidad / Impacto} & \textbf{Mitigación} \\
				\hline
				R1 & Dedicación y plazos insuficientes para cubrir todo el trabajo. & Alta / Media & Definir un cronograma detallado; priorizar tareas críticas; revisiones periódicas de avance. \\
				\hline
				R2 & Sensores de baja calidad generan datos poco fiables. & Muy alto / Bajo & Modularizar el diseño para facilitar su sustitución. \\
				\hline
				R3 & Vulnerabilidades en la seguridad y privacidad de datos. & Bajo / Alto &  Cifrado en base de datos; cumplir normativas de protección de datos. \\
				\hline
				R4 & Problema de producción de la pulsera & Alto / Muy Bajo & Centrarse en un prototipo funcional sin enfocarse en la ergonomía \\
				\hline
			\end{tabular}
		\end{table}
	
		\subsection{Stakeholders}
		
		Un stakeholder (o parte interesada) es cualquier persona, grupo u organización que tiene un interés o impacto directo en el proyecto.
		
		\begin{table}[ht]
			\centering
			\caption{Stakeholders Principales}
			\begin{tabular}{|p{3cm}|p{6cm}|p{7cm}|}
				\hline
				\textbf{Nombre} & \textbf{Representa} & \textbf{Rol} \\ 
				\hline
				Administrador (Desarrollador de software) &
				Responsable de la implementación y mantenimiento del firmware de la pulsera y la plataforma web. &
				Configura funcionalidades, garantiza la integridad de los datos y la comunicación entre dispositivo y servidor. \\
				\hline
				Personal médico &
				Profesionales de la salud que atienden a pacientes con riesgo cardíaco o de edad avanzada. &
				Monitorean constantes vitales y caídas, reciben alertas y ajustan tratamientos en tiempo real. \\
				\hline
				Paciente &
				Usuario final que lleva la pulsera para seguimiento. &
				Registra su actividad y constantes, consulta resultados, recibe alertas y comunica síntomas al médico. \\
				\hline
			\end{tabular}
		\end{table}
	
	\section{Elección de componentes electrónicos}
	
	
	En el mercado existen numerosas opciones que cumplen los requisitos de este proyecto, un microcontrolador con conectividad Wi-Fi y sensores capaces de medir aceleraciones para detección de caídas, así como señales ópticas para frecuencia cardíaca y saturación de oxígeno. A continuación se justifica la elección de cada componente para el caso del prototipo, pero en el trabajo se favorece lógica modular que permita el futuro cambio de componentes en caso de necesitar trabajar con mejores sensores.
	
	\subsection{Microcontroladores IoT}
	
	Para el prototipo de la pulsera se ha seleccionado la placa \textbf{TTGO T-Display (16\,MB)} (ver figura \ref{fig:ttgo_tdisplay_pines}) basada en el módulo ESP32. Este microcontrolador de bajo coste resulta ideal por integrar, en un único módulo, una pantalla TFT de 1.14\,\textquotedbl{} (135×240 px), gestión de batería Li-Ion y la inclusión de conectividad inalámbrica permite la transmisión de datos, mientras que la pantalla facilita una interfaz amigable para el usuario sin hardware adicional \cite{TTGO2021}.
	
	\noindent\textbf{Este módulo permite \cite{TTGO2021}:}
	\begin{itemize}
		\item \textbf{MCU:} ESP32 Xtensa dual-core LX6 (240 MHz). Este procesador de alto rendimiento permite gestionar en paralelo la adquisición de datos de sensores y la actualización de la interfaz gráfica.
		\item \textbf{Memoria Flash:} 16 MB, preferible para mostrar un interfaz con fondo de pantalla animado y capacidad de almacenaje de datos.
		\item \textbf{Pantalla:} 1.14 pulgadas, ST7789V IPS TFT, 135×240 px, 260 PPI, interfaz SPI
		\item \textbf{Conectividad inalámbrica:} Wi-Fi 802.11 b/g/n y Bluetooth 4.2 + BLE, esenciales para la transmisión de datos a la plataforma.
		\item \textbf{Alimentación:} 3.3 V, circuito de carga Li-Ion TP4054 y detección de nivel de batería, garantizando autonomía y avisos de carga.
		\item \textbf{Periféricos:} 2 botones (Ver figura 1, GPIO L006 e I007) configurables como botones de emergencia, y capacidad para integrar sensores adicionales.
	\end{itemize}
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=1\textwidth]{images/TTGO_T-Display.jpg}
		\caption[Diagrama de pines de la TTGO T-Display]{Diagrama de la placa \mbox{TTGO T-Display (16\,MB)} con todos sus pines de conexión.}
		\label{fig:ttgo_tdisplay_pines}
	\end{figure}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{ESP32 DevKitC / NodeMCU / LOLIN32}: mismo ESP32 de bajo coste pero no cuenta con pantalla, botones ni gestión de batería (coste aproximado: 5–8\,\texteuro{}) \cite{ESP32DevKitC2018}.
		\item \textbf{Arduino Nano 33 IoT / UNO Wi-Fi Rev2}: ARM Cortex-M0/M4 con Wi-Fi/BLE integrados, pero sin pantalla y más caro (coste aproximado: 30 \texteuro{}) \cite{ArduinoNano33IoT2019}.
		\item \textbf{M5Stack Core2}: basado en ESP32, incluye pantalla touchscreen de 2 pulgadas (320×240 px), y las funcionalidades pero por un mayor coste. (coste aproximado: 50\,\texteuro{}) \cite{M5StackCore22020}.
	\end{itemize}
	
	
	\subsection{Acelerómetros y detección de caídas}
	
	Para la detección de caídas en el prototipo se ha seleccionado el IMU \textbf{MPU-6050} (ver figura \ref{fig:mpu}), un dispositivo de bajo coste (aproximadamente 1\,\texteuro{}) de 6 ejes que combina acelerómetro y giroscopio con conversión A/D de 16 bit y un DMP (Digital Motion Processor) integrado. 	
	
	\noindent\textbf{Este módulo permite \cite{MPU6050Datasheet}:}
	\begin{itemize}
		\item \textbf{Medición de aceleración:} ±2/4/8/16 g, suficiente para capturar picos de impacto y cambios bruscos de movimiento en caídas .
		\item \textbf{Medición de rotación:} ±250/500/1000/2000 °/s, útil para caracterizar la orientación y la fase de giro durante una caída.
		\item \textbf{DMP integrado:} fusión inicial de acelerómetro y giroscopio en hardware, que descarga parte del procesamiento de la MCU y permite ejecutar algoritmos de detección en tiempo real con menor latencia.
		\item \textbf{Interfaz I\textsuperscript{2}C:} funciona a hasta 400 kHz, simplificando el cableado y compartiendo bus con otros sensores (por ejemplo MAX30102).
	\end{itemize}
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{images/MPU6050.png}
		\caption[Diagrama de pines del MPU6050]{Diagrama del  \mbox{MPU6050)} con todos sus pines de conexión.}
		\label{fig:mpu}
	\end{figure}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{ADXL345}: acelerómetro de 3 ejes, ±2/4/8/16 g, A/D de 13 bit, interfaz I\textsuperscript{2}C/SPI; buena precisión estática pero requiere un giroscopio externo para fusión completa su coste es similar al MPU6050 \cite{ADXL345Datasheet}.
		\item \textbf{BNO055}: IMUs de 9 ejes con magnetómetro o fusión completa en chip; ofrece mayor certeza en orientación espacial, pero a un coste superior (coste aproximado 10 \texteuro{}) \cite{BNO055Datasheet}.
	\end{itemize}

	\subsection{Sensor de pulso y oxímetro}
	
	Para la medición de frecuencia cardíaca y saturación de oxígeno (SpO$_2$) se ha seleccionado el módulo \textbf{GY-MAX30102} (ver figura \ref{fig:max}), que integra el sensor óptico MAX30102 con las siguientes características \cite{MAX30102Datasheet}:
	\begin{itemize}
		\item \textbf{Longitudes de onda:} LED rojo a 660 nm e infrarrojo a 880 nm, adecuadas para la discriminación hemoglobínica.
		\item \textbf{Conversión A/D:} resolución de 18 bit, que permite un amplio rango dinámico de señal.
		\item \textbf{Interfaz I\textsuperscript{2}C:} bus estándar a 400 kHz para comunicación con la MCU.
		\item \textbf{Dimensiones y consumo:} encapsulado compacto (5×3 mm) y consumo de operación típico en torno a 600 µA por LED.
	\end{itemize}
	
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{images/MAX30102.png}
		\caption[Diagrama de pines del MAX30102]{Diagrama del  \mbox{MAX30102)} con todos sus pines de conexión.}
		\label{fig:max}
	\end{figure}
	
	
	\noindent\textbf{Ventajas:}
	\begin{itemize}
		\item Muy económico (coste aproximado 1 a 2 \texteuro{}).
		\item Diseño modular que facilita su sustitución futura por sensores de mayor precisión.
	\end{itemize}
	
	\noindent\textbf{Limitaciones:}
	\begin{itemize}
		\item No homologado para uso clínico; su precisión es inferior a la de equipos médicos profesionales.  
		\item Algunas placas genéricas presentan fallas de diseño, lo que impide su funcionamiento \cite{LuisLlamas2021}.
	\end{itemize}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{MAX30100}: predecesor con A/D de 16 bit y menor resolución, fue probado y termino siendo descartado. \cite{MAX30100Datasheet}.
		\item \textbf{MAX86150}: sensor combinado (ECG + PPG) con mayor precisión y funcionalidades integradas (coste aproximado 15 \texteuro{}) \cite{MAX86150Datasheet}.
		\item \textbf{TSL2561 + pulsioxímetro genérico}: uso de fotodetector independiente para PPG, que aumenta la complejidad de diseño y calibración (coste aproximado 12\texteuro{}).
	\end{itemize}
		
	

\section{Diseño de la pulsera (Hardware)}
	
	El objetivo es presentar una solución sencilla y modular que sirva como base. Aún usando sensores de bajo coste, se mantienen buenas prácticas de ingeniería: arquitectura en bus I\textsuperscript{2}C, y disposición clara de pines, de manera que el prototipo pueda evolucionar hacia un producto más robusto en caso de ser necesario y tener el presupuesto para comprar sensores de calidad.
	
	\subsection{Esquemáticos y PCB}
	
	A continuación se muestra la tabla de conexiones entre el ESP32 y los sensores MAX30102 y MPU-6050. Solo se emplean las líneas estrictamente necesarias, dejando libres pines adicionales que no son requeridos para este proyecto.

	\begin{table}[ht]
		\centering
		\caption{Conexión del sensor de pulso GY-MAX30102}
		\label{tab:conexion_max30102}
		\begin{tabular}{|p{4cm}|p{3cm}|p{5cm}|}
			\hline
			\textbf{Pin del MAX30102} & \textbf{Pin del ESP32}      & \textbf{Uso}                    \\ \hline
			VIN                        & 3.3\,V                       & Alimentación                          \\ \hline
			GND                        & GND                          & Tierra                                   \\ \hline
			SCL                        & GPIO 22 (SCL)                & I\textsuperscript{2}C reloj            \\ \hline
			SDA                        & GPIO 21 (SDA)                & I\textsuperscript{2}C datos            \\ \hline
			INT                        & —                            & No utilizado en este prototipo        \\ \hline
		\end{tabular}
	\end{table}
	
		
	
	Para simplificar el cableado y aprovechar el bus I\textsuperscript{2}C, ambos sensores comparten las mismas líneas de reloj (SCL) y datos (SDA) en el ESP32. En particular, GPIO 22 (SCL) y GPIO 21 (SDA) pueden conectarse en paralelo a múltiples dispositivos I\textsuperscript{2}C sin interferencias, ya que el protocolo gestiona direcciones únicas para cada sensor, por lo cual no es ningún problema reutilizar estos pines.
	
	
	\begin{table}[ht]
		\centering
		\caption{Conexión del IMU MPU-6050}
		\label{tab:conexion_mpu6050}
		\begin{tabular}{|p{3.5cm}|p{3cm}|p{5cm}|}
			\hline
			\textbf{Pin del MPU-6050} & \textbf{Pin del ESP32}      & \textbf{Uso}                            \\ \hline
			VCC                        & 3.3\,V                       & Alimentación                                  \\ \hline
			GND                        & GND                          & Tierra                                           \\ \hline
			SCL                        & GPIO 22 (SCL)                & I\textsuperscript{2}C reloj                    \\ \hline
			SDA                        & GPIO 21 (SDA)                & I\textsuperscript{2}C datos                    \\ \hline
			XDA                        & —                            & No necesario (uso I\textsuperscript{2}C)        \\ \hline
			XCL                        & —                            & No necesario (uso I\textsuperscript{2}C)        \\ \hline
			ADO                        & —                            & Dirección I\textsuperscript{2}C fija (0x68)     \\ \hline
			INT                        & —                            & No utilizado en este prototipo                \\ \hline
		\end{tabular}
	\end{table}
	
	
	En la figura \ref{fig:esquema_prototipo}, se puede observar un esquemático realizado, mostrando todas las conexiones que se esperan hacer para permitir el funcionamiento del microcontrolador y sensores.
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{images/esquema_prototipo.jpg}
		\caption[Esquemático del prototipo]{Esquemático de conexión entre el ESP32 y los sensores MAX30102 y MPU-6050.}
		\label{fig:esquema_prototipo}
	\end{figure}
	
	
	\subsection{Desarrollo de software del prototipo}
	
	Ya conociendo los componentes elegidos para este proyecto se puede describir el código usado en arduino. El código fuente del prototipo está disponible como material complementario en la carpeta \texttt{CODE} de este  
	\href{https://github.com/Diegodepab/TFG_Pulsera_Seguimiento_Pacientes_Avanzada_Edad/tree/main/CODE}{repositorio Github}.
	
	Uno de los principales objetivos del prototipo es explorar una variedad amplia de funciones probando su viabilidad, además de tener un enfoque basado en componentes donde sin importar el tamaño del código se busca minimizar la cohesión diseñando módulos de tal manera que tengan menos dependencias internas entre sí, favoreciendo un futuro donde sustituciones o problemas en un sensor no afecten el funcionamiento global de la pulsera.
	
	El prototipo se divide en las siguientes funcionalidades:
	
		\subsubsection{Uso del sensor GY‑MAX30102}
	Para gestionar el sensor GY‑MAX30102 se utiliza la librería \texttt{MAX30105.h}, que simplifica la configuración y lectura del señales. En el código, se realiza:
	
	\begin{enumerate}
		\item \textbf{Inicialización:} Se comprueba el funcionamiento y conexión del sensor, además se ajusta brillo, modo y frecuencia de muestreo.
		\item \textbf{Lectura:} El sensor verifica constantemente si puede realizar un análisis sin detener el flujo principal.
		\item \textbf{Extracción de muestras:} El MAX30102, equipado con LEDs rojo e infrarrojo, al colocarse en la piel (dedo o muñeca) mide la luz reflejada para calcular la saturación captando el distinto comportamiento que la sangre tiene ante la luz.
		\item \textbf{Evaluación de muestras:} Se usa la librería para traducir las señales a ritmo cardíaco y saturación de oxígeno, además de descartar las lecturas inválidas.
		\item \textbf{Procesado:} las lecturas válidas se copian en buffers y se hace una media para calcular frecuencia cardíaca y SpO\textsubscript{2} más acertados posibles.
		\item \textbf{Salida:} Se actualiza la pantalla con los valores procesados, y opcionalmente se envían.
	\end{enumerate}
	
	\subsubsection{Uso del sensor MPU‑6050}
	Se emplea la librería \texttt{MPU6050\_light.h} para obtener aceleraciones y aplicar ajustes de calibración, ofreciendo dos funciones:
	
	\begin{enumerate}
		\item \textbf{Detección de caída:}
		\begin{enumerate}
			\item Para la detección de caídas se ha establecido un umbral de aceleración de 3.5g. Este valor se define en el código como referencia para identificar cambios bruscos en los ejes X, Y o Z que puedan indicar una caída. El umbral se ha seleccionado basándose en los sistemas de detección existentes y pruebas iniciales; este parámetro debe considerarse orientativo y ajustarse individualmente según las características, edad y patologías del paciente, para optimizar la sensibilidad y especificidad del sistema.
			\item Si se supera, se muestra alerta y se envía el evento por MQTT.
		\end{enumerate}
		\item \textbf{Podómetro:}
		\begin{enumerate}
			\item Se aplica un filtro de media móvil (ventana fija) sobre la señal Z.
			\item Se detecta un paso cuando la señal filtrada supera el umbral y ha pasado el intervalo mínimo entre pasos.
			\item Se incrementa el contador de pasos y se actualiza la pantalla.
		\end{enumerate}
	\end{enumerate}
	

	\subsubsection{Medición de tiempo}
	Para gestionar la fecha y hora de la pulsera se emplea la librería \texttt{<time.h>}, que facilita la sincronización NTP (De sus siglas en inglés Network Time Protocol, protocolo que mantiene los relojes de los sistemas informáticos alineados con gran precisión).
	
	La inicialización y uso se estructura en tres funciones clave:
	\begin{enumerate}
		\item En caso de tener conexión Wi-Fi obtiene la hora de España y sincroniza, en caso contrario usa la hora cargada.
		\item Se muestra la hora y minuto en la parte superior de la pantalla.
		\item Se guarda un registro de los datos con la hora antes de ser enviados, para tener un mayor control de las mediciones y ver la evolución temporal de los datos.
	\end{enumerate}
	
	\subsubsection{Conexión Wi‑Fi}
	Se emplea la librería \texttt{WiFi.h} para conectar la pulsera a la red:
	
	\begin{enumerate}
		\item \textbf{Inicio de conexión:}
		\begin{enumerate}
			\item En el código se da el SSID (Service Set Identifier) que es el nombre público de la red Wi‑Fi y la contraseña para entablar conexión.
			\item Si conecta, se muestra la dirección IP en el monitor serie y continua con demás funciones que ameritan internet.
		\end{enumerate}
		\item \textbf{Gestión de fallo:}
		\begin{enumerate}
			\item Si no conecta en el tiempo límite, se muestra un mensaje de error en pantalla. El dispositivo intentará reconectar de forma periódica y también lo hará cada vez que haya un nuevo dato que deba enviarse (en el prototipo los valores se envían cada minuto o ante una situación de alarma; esta cadencia puede modificarse). Mientras no exista conectividad, las muestras se almacenan temporalmente en el buffer circular configurado del dispositivo y, al recuperarse la conexión, los datos pendientes se reenvían al broker. Si el buffer alcanza su capacidad, se aplica la política de desbordamiento descrita en la sección «Almacenamiento de datos sin conexión».
	
		\end{enumerate}
	\end{enumerate}
	
	\subsubsection{Conectividad MQTT y envío de datos}
	
	Se utiliza la librería \texttt{PubSubClient.h} sobre TCP/IP para publicar eventos y métricas:
	
	\begin{enumerate}
		\item \textbf{Inicialización y conexión:} Intenta acceder al broker y puerto indicados, intentando suscribirse como cliente. En caso de fallo, se reintenta tras un intervalo fijo (1 minuto) o inmediatamente cuando existe una alarma pendiente.
		\item \textbf{Política de reconexión:} Al arrancar, la pulsera intenta conectar a la red Wi-Fi durante un tiempo límite (5\,s por defecto). Si no se establece conexión, se muestra un aviso en pantalla y el dispositivo reintenta periódicamente, así como cada vez que genera una nueva métrica. De forma análoga, si el broker MQTT no está disponible, la pulsera almacena temporalmente los datos en un buffer circular y los reenvía automáticamente al recuperarse la conexión.
		\item \textbf{Frecuencia de envío:} Por defecto, las métricas se publican cada 60\,000 ms (1 minuto), además de manera inmediata en caso de producirse una alarma.
		\item \textbf{Formato de mensajes:} Las métricas y eventos se transmiten en JSON, con ejemplos como los siguientes:
	\end{enumerate}

	{\ttfamily\small
		\noindent
		\{\\
		\quad "step\_count": 12,\\
		\quad "bpm": 72,\\
		\quad "spo2": 97,\\
		\quad "ts": "2025-09-04T12:34:56Z"\\
		\}\\[6pt]
		\noindent
		\{\\
		\quad "start\_ts": "2025-09-04T12:00:00Z",\\
		\quad "end\_ts": "2025-09-04T12:59:00Z",\\
		\quad "total\_steps": 348,\\
		\quad "avg\_bpm": 73,\\
		\quad "avg\_spo2": 96,\\
		\quad "samples": 60\\
		\}\\[6pt]
		\noindent
		\{\\
		\quad "ts":"2025-09-04T12:35:01Z",\\
		\quad " event":" ALERTA\_CAIDA",\\
		\quad "dx":2.4,"dy":4.1,"dz":0.8\\
		\}
	}

	\subsubsection{Almacenamiento de datos sin conexión}
	Se implementó un buffer circular de tamaño configurable para conservar temporalmente las lecturas cuando la pulsera no puede enviarlas por falta de conectividad. Su funcionamiento principal es:
	
	\begin{enumerate}
		\item \textbf{Inserción:}
		\begin{enumerate}
			\item Si no es posible enviar una métrica (Wi-Fi o MQTT no disponibles), la muestra se guarda en la caché con marca temporal, pasos y valores medios de \texttt{bpm} y \texttt{SpO\textsubscript{2}}.
		\end{enumerate}
		
		\item \textbf{Gestión de desbordamiento:}
		\begin{enumerate}
			\item Cuando la caché alcanza su capacidad, se reduce la ocupación combinando pares de muestras en una sola entrada: los pasos y marcas de tiempo se mantienen del segundo y los valores de \texttt{bpm} y \texttt{SpO\textsubscript{2}} se promedian.
		\end{enumerate}
		
		\item \textbf{Reenvío:}
		\begin{enumerate}
			\item Al recuperarse la conectividad se calcula un resumen agregado (intervalo temporal, pasos totales, \texttt{avg\_bpm}, \texttt{avg\_SpO\textsubscript{2}} y número de muestras) y se publica como un único mensaje al broker.
		\end{enumerate}
	\end{enumerate}
	
	
	\subsubsection{Fondos animados y botones de la pantalla}
	Para gestionar la pantalla y los botones integrados del TTGO T-Display se usa la librería \texttt{TFT\_eSPI}, la cual está optimizada y permite enviar directamente mapas de bits desde \texttt{PROGMEM} sin consumir RAM, abstrae la inicialización de pines y velocidad de bus.
	
	La función \texttt{handleButtonsAndAnimation()} unifica dos tareas clave:
	\begin{enumerate}
		\item \textbf{Gestión de botones de emergencia:}
		\begin{enumerate}
			\item Los botones integrados se encuentran en los pines \texttt{GPIO0} y \texttt{GPIO35}. 
			\item Pulsación simultánea de ambos botones por más de 2 segundos muestra en pantalla  que se ha presionado ambos botones y realiza una publicación MQTT de alerta.  
			\item Al pasar 2 segundos la pulsera vuelve a la normalidad.
		\end{enumerate}
		\item \textbf{Animación de fondo}, esta función fue simplificada en el prototipo final para favorecer el uso de memoria en la cache usando solo un frame estático, pero se usa en el ejemplo de pulsera sin conexión Wi-Fi.  
		\begin{enumerate}
			\item Se incluyen diez frames estáticos (\texttt{frame\_000.h}…\texttt{frame\_009.h}) generados previamente con un script Python que convierte GIFs en arrays de 16‑bit.  
			\item Dichos frames serán cambiados cada 100 ms dando una apariencia de movimiento real.
		\end{enumerate}
	\end{enumerate}
	
	\subsection{Protocolos de comunicación}
	
	Para la transmisión de las métricas y alertas del prototipo se eligió el protocolo MQTT (Message Queuing Telemetry Transport). MQTT es un protocolo de mensajería ligero basado en el patrón publicación/suscripción mediante la figura central de un \emph{broker}, lo que permite desacoplar emisores y receptores en tiempo y en espacio. Esta topología resulta especialmente ventajosa en sistemas embebidos de recursos limitados, como el ESP32, porque reduce la complejidad del firmware (el nodo solo publica y/o se suscribe a \emph{topics}) y simplifica la escalabilidad del sistema al centralizar el enrutado de mensajes en el broker \cite{mosquitto,aws_mqtt}.
	
	Las razones principales para elegir MQTT en este proyecto son su ligereza y su eficiencia: el protocolo tiene una sobrecarga de control reducido y mecanismos integrados (por ejemplo, niveles de QoS) que permiten ajustar la fiabilidad de entrega según la criticidad del dato (QoS 0/1/2), optimizando así el uso de ancho de banda y el consumo energético del dispositivo. Además, MQTT soporta sesiones persistentes y reconexiones automáticas que facilitan la recuperación tras pérdidas temporales de cobertura —característica útil en dispositivos móviles o con redes inestables— y permite almacenar mensajes en el broker hasta que los clientes vuelvan a estar disponibles \cite{seoane2021,aws_mqtt}.
	
	Estas características ofrecen un equilibrio adecuado entre coste, consumo y fiabilidad: el dispositivo puede enviar pequeñas cargas con periodicidad reducida (por ejemplo, mediciones cada minuto) y confiar en el broker para la distribución y el reenvío en caso de desconexiones, mientras que la plataforma central puede suscribirse a los topics relevantes para procesar alarmas y registros históricos. Por todo ello, MQTT constituye una solución ampliamente utilizada y bien soportada. \cite{mosquitto,hernandez2024}.

	Para una guía práctica sobre la instalación y prueba de un broker Mosquitto y la configuración de un ESP32 para publicar mensajes MQTT, véase el Apéndice~\ref{sec:pub_mqtt_esp32}.
	
	
	
	\subsection{Ejemplo en funcionamiento}
	
	
	El prototipo desarrollado tiene carácter demostrativo: su diseño prioriza la facilidad de montaje y se han elegido componentes económicos que, como se mencionó anteriormente, no llegan a dar la fiabilidad para un tema tan importante como es el monitoreo de pacientes o personas de avanzada edad. Por ello, los componentes escogidos (ESP32, sensor de pulso/SpO\textsubscript{2} MAX30102 y acelerómetro/giroscopio MPU-6050) permiten validar conceptos y flujos de datos, pero no garantizan la precisión necesaria para monitorizar pacientes o personas de edad avanzada en entornos clínicos reales.
	
	La Figura \ref{fig:prototipo} muestra el montaje final en protoboard, correspondiente al esquemático. En este prototipo se puede alimentar con una conexión tipo C como se muestra en la figura tanto de una batería portable o cualquier fuente de poder. También se podría recomendar la conexión  de una batería LiPo (polímero de litio) que es una batería recargable que utiliza un electrolito en forma de polímero en lugar de un líquido cumpliendo  una tensión de 3.3V para su funcionamiento. No es necesario tener conectado algún cable de comunicación externo al prototipo.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.4\textwidth]{images/prototipo.jpg}
		\caption[Prototipo]{Prototipo mostrando la conexión entre el ESP32 y los sensores MAX30102 y MPU-6050 en protoboard.}
		\label{fig:prototipo}
	\end{figure}

	La pulsera, al ser conectada a una fuente de poder, comprobará que los sensores estén funcionando correctamente. Una vez confirmado que la conexión es correcta, procederá a evaluar la conexión Wi-Fi y el broker MQTT; en caso de que alguno de estos falle, saldrá un aviso como el de la figura \ref{fig:error}, y la pulsera guardará los datos hasta que se logre hacer la conexión.
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.4\textwidth]{images/error_wifi.jpg}
		\caption[Ejemplo]{Ejemplo de mensaje de error de conexión al no encontrar el Wi-Fi.}
		\label{fig:error}
	\end{figure}
	
	
	La pulsera constantemente irá registrando los valores del MPU6050 para que, en caso de movimientos, determine si son pasos, los cuales aumentarán el contador de pasos en la pantalla. Finalmente, se usó el sistema de detección de caídas basado en acelerómetro que evalúa la magnitud máxima del vector de aceleración, es decir, un movimiento muy rápido de manera abrupta. Como se mencionó, esto es basado en un umbral que idealmente sería modificado para ajustarse al estilo de vida de la persona, evitando falsos positivos por movimientos cotidianos. En caso de detectar una caída, se mostrará la pantalla de alarma roja indicando que se detectó una caída y se enviará una notificación de alarma junto a los ejes para determinar qué tan brusco fue el movimiento.
	
	En el caso de la monitorización cardíaca; el uso de la librería permite la detección de piel cercana al sensor; en caso de no detectar directamente, no realiza ningún análisis. En el protoboard, se recomienda usar un dedo cómo se muestra en la figura \ref{fig:sangre}; no obstante, también puede usarse la muñeca u otras partes para realizar un análisis. Mientras se realiza, hay un umbral que descarta los valores anómalos causados por la baja calidad del sensor, y va promediando los valores con sentido que se van detectando, llegando a obtenerse una leída de datos por segundo que modificará el valor visto en la pantalla. Por practicidad, lo que se hace actualmente es una lectura por cada minuto; será enviada por protocolo MQTT, enviando el tiempo, los pasos acumulados, el BMP y SpO\textsubscript{2}.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.35\textwidth]{images/analizando.jpg}
		\caption[Ejemplo]{Ejemplo de análisis de ritmo cardíaco y oxigenación en sangre.}
		\label{fig:sangre}
	\end{figure}
	
	El resto de las funcionalidades siguen la lógica descrita en el apartado de desarrollo de software. 
	Para información práctica y ejemplos de uso, se recomienda consultar el Apéndice~\ref{sec:proto} (Manual de usuario). 
	Además, está disponible un \href{https://www.youtube.com/watch?v=y1xrh9f9NOg}{vídeo demostrativo en YouTube} que muestra todas las funcionalidades.

\section{Diseño de la base de datos}


La base de datos se ejecuta una instancia de PostgreSQL versión 13.3 como base de datos principal del proyectoo. Toda la lógica de manejo, migración y acceso a la base de datos se realiza con código Python en el backend.



\subsection{Uso de PostgreSQL}

Para la persistencia de los datos del proyecto se optó por PostgreSQL (versión 13.x en la configuración del servicio). PostgreSQL es un sistema gestor de bases de datos relacional, libre y maduro, con soporte ACID, amplia adopción industrial y capacidades avanzadas (tipos JSONB, índices, extensiones, etc.). Estas características lo hacen especialmente adecuado cuando se buscan garantías de integridad y escalabilidad sin coste de licenciamiento, facilitando además la trazabilidad y auditoría de datos en aplicaciones de telemonitorización \cite{postgresql_doc,postgresql_13}.

En el contexto de un proyecto con dispositivos ESP32 que envían telemetría, PostgreSQL aporta un almacén robusto para series temporales, eventos y registros agregados, permitiendo consultas relacionales complejas para análisis y generación de informes, facilitando el seguimiento de datos en caso de algún error.

\subsection{Implementación y despliegue con contenedores}

Para facilitar el despliegue reproducible y el desarrollo, se emplea PostgreSQL en un contenedor (Docker). La contenedorización permite materializar una instancia de base de datos preconfigurada con las siguientes consideraciones operativas:

\begin{itemize}
	\item \textbf{Variables de entorno:} la creación inicial del usuario, la contraseña y la base de datos se define mediante variables de entorno estándar \texttt{POSTGRES\_PASSWORD}, (\texttt{POSTGRES\_USER}, \texttt{POSTGRES\_DB}), lo que permite parametrizar entornos (desarrollo, pruebas, producción) sin modificar la imagen base \cite{docker_postgres}.
	\item \textbf{Persistencia:} los datos se mantienen en un volumen dedicadopara evitar pérdida de información al reiniciar o recrear contenedores; además se puede montar un directorio con scripts de inicialización que se ejecutan la primera vez que se crea la base \cite{docker_persist,docker_postgres}.
	\item \textbf{Acceso por red y puertos:} el contenedor expone el puerto interno 5432, que puede mapearse a un puerto del host (por ejemplo 15432) para permitir conexiones externas desde entornos de desarrollo o herramientas de administración.
	\item \textbf{Logs y gestión:} la gestión de logs se realiza mediante las opciones de logging de Docker y políticas de rotación, limitando tamaño y número de archivos para facilitar la depuración y evitar consumos indeseados de disco. La orquestación con Docker Compose aporta reproducibilidad y automatización en el ciclo de vida de la base de datos \cite{docker_persist}.
\end{itemize}

Estas prácticas facilitan levantar y administrar la base de datos de forma automática y reproducible, permiten ejecutar scripts de inicialización y garantizan portabilidad entre distintos entornos.

\subsection{Integración con Python y control de esquema}

La aplicación Python se conecta a PostgreSQL mediante drivers y bibliotecas especializadas. Se psycopg2 como adaptador DB-API para PostgreSQL; sobre estos drivers se emplean otras librerías como SQLAlchemy que sirve de capa de abstracción/ORM para modelar entidades y consultas en Python \cite{psycopg2_doc,sqlalchemy_doc}.

Para el control y evolución del esquema (migraciones) el proyecto utiliza Alembic, la herramienta de migraciones asociada a SQLAlchemy. Alembic permite versionar cambios en la estructura de la base de datos (creación de tablas, alteración de columnas, índices, etc.) mediante scripts de migración reproducibles, lo que facilita desplegar actualizaciones del esquema en distintos entornos y mantener sincronizada la base con el código de la aplicación \cite{alembic_doc}.



\subsection{Modelo entidad-relación}

Antes de la implementación física se define un diagrama entidad-relación (ER) que refleje las entidades principales y su importancia en la aplicación, en la figura \ref{fig:db} se puede ver las principales tablas con las que se trabajará en este proyecto.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{images/db_bracelet.png}
	\caption[Modelo entidad-relación]{Modelo entidad-relación.}
	\label{fig:db}
\end{figure}

\subsubsection{Generalidades: trazabilidad y metadatos temporales}

Todas las tablas del esquema incluyen dos columnas de auditoría temporal: \texttt{create\_ts} y \texttt{update\_ts}.  

\begin{itemize}
	\item \texttt{create\_ts} (TIMESTAMP): indica la fecha y hora en que la fila fue creada. 
	\item \texttt{update\_ts} (TIMESTAMP): refleja la última modificación de la fila. En el esquema se implementa mediante un trigger que actualiza \texttt{update\_ts = now()} antes de cada \texttt{UPDATE}, lo que permite auditar cambios y detectar discrepancias en registros clínicos o administrativos.
\end{itemize}

Dado que el trabajo está relacionado con la salud, mantener estas marcas temporales y registros inmutables es una práctica esencial para reconstruir la secuencia de eventos y cumplir requisitos de trazabilidad en aplicaciones sanitarias.

\subsubsection{Explicación de cada tabla}
A continuación, se describen las tablas principales del modelo de datos.  
Cada entrada incluye los campos relevantes y una breve justificación de su importancia en el sistema.



\textbf{1) user\_account:} Centraliza la autenticación, la gestión de usuarios (cuidadores, administradores, pacientes) y permite auditar acciones por cuenta, es la tabla más importante de la plataforma.


\begin{itemize}
	\item \texttt{id} (INTEGER, PK, autoincrement). Ejemplo: \texttt{1}. Identificador único de la cuenta.
	\item \texttt{email} (VARCHAR(255), UNIQUE). Ejemplo: \texttt{admin@bracelet.io}. Sirve para autenticar y contactar al usuario.
	\item \texttt{password} (VARCHAR(255)). Ejemplo: \texttt{\textless hashed password\textgreater}. Almacena el hash de la contraseña (nunca en texto claro).
	\item \texttt{user\_role\_name} (VARCHAR(64), FK \texttt{user\_role.name}). Ejemplo: \texttt{admin}. Cuenta con su propia tabla y vincula los permisos asociados, Admin permisos completos, user es el caso de Doctores, cuidadores o personal encargado con mucha responsabilidad y paciente que correspondería a datos personales y acceso al chat con su doctor.
	\item \texttt{user\_status\_name} (VARCHAR(64), FK \texttt{user\_status.name}). Ejemplo: \texttt{active}. Indica visibilidad / estado de la cuenta, al crear una cuenta debe ser revisada por un admin para activarla.
	\item \texttt{first\_name}, \texttt{last\_name} (VARCHAR). Ejemplo: \texttt{Diego}, \texttt{De Pablo}. Datos identificativos.
	\item \texttt{phone} (VARCHAR(64)). Ejemplo: \texttt{+177 555-555-555}. información para hacer realista la plataforma.
	\item \texttt{approval\_toc\_ts} (TIMESTAMP). Fecha en que aceptó Términos y Condiciones.
	\item \texttt{blocked\_ts} (TIMESTAMP). Marca si la cuenta fue bloqueada desde determinada fecha, con un número elevado de intentos fallidos de inicio de sección se bloquea la cuenta por seguridad.
\end{itemize}


\textbf{2) user\_role:} Define conjuntos de permisos y separa responsabilidades (quién puede ver/editar datos clínicos, quién solo visualiza).

\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{admin}, \texttt{user} o \texttt{patient}.
\end{itemize}


\textbf{3) user\_status:} Permite otra capa de seguridad al controlar la confirmación al crear una cuenta o el bloquear cuentas con actividad sospechosa.

\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{active}, \texttt{pending}, \texttt{blocked}.
\end{itemize}


\textbf{4) permission\_grant:} Catálogo para asignar niveles de acceso granular sobre las entidades del sistema, el administrador tendrá todos los permisos siempre y ya dependiendo de las actividades las cuentas no tendrán permisos o solo de lectura.


\begin{itemize}
	\item \texttt{name} (VARCHAR, PK). Ejemplo: \texttt{none}, \texttt{read}, \texttt{write}.
\end{itemize}

\textbf{5) entity:} Lista de objetos del dominio sobre los que se aplican permisos (permite gestionar ACL por entidad, evitando errores de tipos y manteniendo buenas prácticas).

\begin{itemize}
	\item \texttt{name} (VARCHAR, PK). Ejemplo: \texttt{patient}, \texttt{study}.
\end{itemize}



\textbf{6) permission:} Centraliza la política de acceso; facilita comprobar permisos desde el frontend.
\begin{itemize}
	\item \texttt{user\_role\_name} (PK componente, FK a \texttt{user\_role}).
	\item \texttt{entity\_name} (PK componente, FK a \texttt{entity}).
	\item \texttt{read}, \texttt{write}, \texttt{delete} (VARCHAR referenciando \texttt{permission\_grant.name}). Ejemplo: \texttt{read='read'}.
	\item \texttt{ui\_visibility} (BOOLEAN, default TRUE). Controla si la entidad aparece en la interfaz para ese rol.
\end{itemize}





\textbf{7) pathology:} Catálogo de patologías clínicas para relacionar al paciente con su historial, también servirá de base de datos de las enfermedades que se manejan en el centro de salud.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{name} (VARCHAR(255)). Ejemplo: \texttt{Diabetes}.
\end{itemize}


\textbf{8) patient:} Nodo central del dominio clínico; relaciona telemetría, alarmas y patologías con la identidad del paciente.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{code} (VARCHAR(255), UNIQUE). Por razones de seguridad se recomendaría guardar un código identificativo para priorizar el anonimato del paciente, pero para mayor entendimiento se trabajo como si fuera nombre y apellido, ejemplo: \texttt{Diego De Pablo}
	\item \texttt{gender} (VARCHAR(64), FK a \texttt{gender\_type.name}). Ejemplo: \texttt{male}.
	\item \texttt{weight} (INTEGER). Ejemplo: \texttt{70} (kg).
	\item \texttt{birth\_date} (DATE). Ejemplo: \texttt{1990-01-01}.
	\item \texttt{owner\_user\_id} (FK a \texttt{user\_account.id}). Ejemplo: \texttt{1} (cuenta del usuario que cuida del paciente).
	\item \texttt{patient\_user\_id} (FK nullable a \texttt{user\_account.id}). Ejemplo: \texttt{15} (si el paciente tiene cuenta propia).
\end{itemize}



\textbf{9) patient\_pathology:} Relación N:M que registra cuándo se detectó una patología en un paciente (historial clínico).
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK a \texttt{patient.id}), \texttt{pathology\_id} (FK a \texttt{pathology.id}).
	\item \texttt{detection\_date} (DATE). Ejemplo: \texttt{2024-03-14}.
\end{itemize}


\textbf{10) gender\_type:} Catálogo de tipos de género para integridad referencial y estandarización de datos.
\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{male}, \texttt{female}, \texttt{other}.
\end{itemize}


\textbf{11) study:} Almacena la telemetría recibida de la pulsera; sirve para análisis temporal, detección de tendencias y generación de informes clínicos.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK a \texttt{patient.id}).
	\item \texttt{step\_count} (INTEGER). Ejemplo: \texttt{1000}. Contador acumulado de pasos.
	\item \texttt{bpm} (INTEGER). Ejemplo: \texttt{75} (latidos por minuto).
	\item \texttt{spo2} (INTEGER, nullable). Ejemplo: \texttt{98} (\%). Nullable porque a veces no hay lectura válida.
	\item \texttt{ts} (TIMESTAMP / timestamptz). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
\end{itemize}

\textbf{12) alarm:} Registro de eventos críticos que requieren respuesta inmediata o análisis posterior; permite priorizar intervenciones según \texttt{is\_urgent}
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK).
	\item \texttt{alarm\_type} (VARCHAR(64)). Ejemplo: \texttt{fall\_detected}, \texttt{button\_alarm}.
	\item \texttt{ts} (TIMESTAMP). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
	\item \texttt{is\_urgent} (BOOLEAN, default FALSE). Ejemplo: \texttt{True}.
\end{itemize}


\textbf{13) chat:} Soporte de mensajería entre usuarios (familiares, cuidadores, personal sanitario, personal de servicio de la aplicación). 
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{user1\_id}, \texttt{user2\_id} (FKs a \texttt{user\_account.id}).
	\item \texttt{administration} (BOOLEAN). Ejemplo: \texttt{False}. Indica chat de soporte/administración si \texttt{True}.
\end{itemize}


\textbf{14) message:} Forma sencilla de almacenar la conversación.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{chat\_id} (FK a \texttt{chat.id}), \texttt{sender\_id} (FK a \texttt{user\_account.id}, \texttt{ON DELETE SET NULL}).
	\item \texttt{content} (TEXT, max\_length \textasciitilde 1000). Ejemplo: \texttt{"Hello, how are you?"}.
	\item \texttt{ts} (TIMESTAMP). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
\end{itemize}


Cada tabla será usada en la plataforma para herramientas que faciliten la telemedicina además de centrarse en utilidad cotidiana del manejo de pacientes.



\subsection{Herramientas de administración}

Para la administración visual y la inspección del esquema se emplea DBeaver, un cliente gráfico multiplataforma que permite explorar tablas, ejecutar consultas SQL y gestionar conexiones. En el apéndice A.4.1 se muestra como manipular DBeaver; su uso acelera las tareas de depuración y validación durante el desarrollo. Como alternativa se dispone de \texttt{pgAdmin} \cite{dbeaver_doc,postgresql_doc}.


\subsection{Población de base de datos}

El proyecto incluye el script \texttt{seed.py}, cuyo propósito es poblar la base de datos con datos de ejemplo y la configuración inicial necesaria para el desarrollo y la demostración. Este script facilita disponer de usuarios, pacientes y registros realistas sin crear manualmente cada entrada; aunque es posible adaptar las variables para cargar datos reales, en este trabajo se opta por datos ficticios para evitar los problemas asociados al tratamiento de información sensible. Para instrucciones detalladas sobre la ejecución de migraciones y la carga de datos (Alembic, Docker, uso de DBeaver, etc.), véase el Apéndice~\ref{sec:seed_db}.


\section{Desarrollo de la plataforma web}


Una plataforma web de telemedicina tiene cada vez mayor relevancia por su capacidad de facilitar el acceso a servicios sanitarios, mejorar el seguimiento remoto de pacientes y optimizar los flujos de trabajo clínicos. Los conocimientos de un ingeniero de la salud (o bioinformático con experiencia en sistemas clínicos) son valiosos porque permiten traducir requisitos clínicos en especificaciones técnicas: identificar necesidades de confidencialidad, latencia y trazabilidad; priorizar la usabilidad para personal sanitario; y diseñar soluciones que integren seguridad, interoperabilidad y validación clínica. Esta visión interdisciplinaria contribuye a que la plataforma sea eficiente, segura y realmente útil para el equipo médico y para los pacientes.


\subsection{Arquitectura general}


El sistema sigue una arquitectura cliente--servidor basada en microservicios, donde cada componente principal se ejecuta en un contenedor independiente gestionado por Docker. Esta aproximación facilita la escalabilidad, el mantenimiento y la replicabilidad del entorno, tanto en desarrollo como en producción. Todos los servicios se comunican por red interna, y NGINX actúa como único punto de entrada externo, funcionando como proxy inverso y servidor estático. El backend (API) gestiona la lógica de negocio y accede a la base de datos PostgreSQL y a Redis para el almacenamiento persistente y temporal de datos. Para una visión global, observar la figura~\ref{fig:diagramaGeneral}.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{images/diagramaGeneral.png}
	\caption[Ejemplo]{Arquitectura general de la plataforma Bracelet}
	\label{fig:diagramaGeneral}
\end{figure}

\subsubsection{Componentes principales}
\begin{description}
	\item[Frontend (cliente)] Interfaz web desarrollada con Svelte. Los usuarios acceden mediante navegador y el frontend realiza peticiones HTTP/HTTPS a la API para obtener o enviar datos.
	\item[Servidor de aplicación (Backend / API)] Contenedor \texttt{API} que ejecuta la lógica de negocio y expone una API REST (puerto \texttt{8001} en este proyecto). Gestiona autenticación, usuarios, dispositivos, estudios médicos y orquesta el acceso a la base de datos y a servicios auxiliares.
	\item[Servidor web / proxy inverso (Nginx)] Contenedor \texttt{nginx} que actúa como punto de entrada HTTP/HTTPS: sirve archivos estáticos del frontend si procede y redirige peticiones al backend. 
	\item[Base de datos (PostgreSQL)] Contenedor \texttt{db} donde se almacenan los datos. El backend se conecta mediante variables de entorno para credenciales y parámetros de conexión. Los datos persisten en volúmenes Docker.
	\item[Servidor de mensajería / caché (Redis)] Contenedor \texttt{redis} usado para caché, gestión de sesiones y colas de tareas (tareas en segundo plano, publish/subscribe para notificaciones).

\end{description}



\subsubsection{Redis}
Redis (REmote DIctionary Server) es un almacén de estructuras de datos en memoria diseñado para ofrecer acceso ultrarrápido a datos volátiles y semipersistentes. Se utiliza habitualmente como \emph{cache} delante de una base de datos relacional, como broker de mensajes (pub/sub y colas) y como motor de streams para procesamiento de eventos en tiempo real \cite{redis_persistence}.

En arquitecturas de microservicios, Redis aporta tres capacidades clave:
\begin{itemize}
	\item \textbf{Caché de lectura y sesión:} reduce la latencia y la carga sobre la base de datos principal almacenando resultados o sesiones en memoria con tiempos de expiración configurables.
	\item \textbf{Mensajería y colas:} mediante patrones pub/sub, listas y streams permite desacoplar productores y consumidores (por ejemplo, notificaciones, envío de correos o procesos asíncronos), con latencias muy bajas propias de un sistema en memoria \cite{redis_pubsub,redis_streams}.
	\item \textbf{Almacenamiento de estado temporal:} cuenta para rate-limiting, contadores, locks distribuidos o datos de sesión de videoconsulta en curso, que exigen alta velocidad de acceso.
\end{itemize}


\subsubsection{Nginx}
 Es un servidor web y proxy inverso orientado a alto rendimiento mediante un modelo de ejecución \emph{event-driven} y asincrónico. Sus usos comunes son servir contenido estático con alta eficiencia, actuar como proxy inverso / puerta de entrada a APIs y realizar balanceo de carga entre réplicas de microservicios. Al situarse como primer punto de entrada, Nginx centraliza funciones transversales como terminación TLS (Transport Layer Security) es el protocolo que cifra y protege la comunicación entre dos extremos (por ejemplo: navegador y servidor web), enrutado según rutas o subdominios, cache de respuesta, limitación de tasa y políticas de seguridad \cite{nginx_reverseproxy,nginx_docs}.


Ventajas que aporta en este proyecto:
\begin{itemize}
	\item Almacenar las claves privadas y certificados con permisos restringidos; montar los ficheros de certificado como volúmenes en Docker y automatizar renovación para evitar expiraciones manuales \cite{certbot_doc}.
	\item Ajustar parámetros de rendimiento y habilitar compresión/control de caché donde sea apropiado para reducir latencia y consumo de ancho de banda.
	\item Usar Nginx como primer filtro: exponer sólo puertos 80/443 externamente, y mantener backend y Redis en redes privadas sin exposición pública.
	\item Comprobar la configuración antes de recargar (\texttt{nginx -t}) y disponer de políticas de restart / healthchecks en Docker Compose para evitar caídas por recargas erróneas.
\end{itemize}

Nginx y Redis actúan de forma complementaria: mientras Nginx optimiza y protege la entrada de tráfico (cifrado, balanceo, caching de respuestas HTTP), Redis acelera el acceso a datos y desacopla procesos internos (cache, colas, streams). Juntos permiten una plataforma de telemedicina con menor latencia, mayor escalabilidad y un punto claro para aplicar políticas de seguridad y observabilidad \cite{nginx_reverseproxy,nginx_loadbalancer,redis_pubsub}.


\subsubsection{Flujo y puentes de comunicación}
\begin{itemize}
	\item \textbf{Frontend \(\rightarrow\) Backend:} Peticiones REST (HTTP/HTTPS) desde la aplicación cliente a la API; autenticación mediante tokens/headers.
	\item \textbf{Backend \(\rightarrow\) Base de datos:} Operaciones CRUD contra PostgreSQL mediante librerías Python (conexión configurable por variables de entorno).
	\item \textbf{Backend \(\rightarrow\) Redis:} Lectura/escritura de datos temporales, gestión de sesiones y encolado de tareas asíncronas.
	\item \textbf{Nginx \(\rightarrow\) Backend/Frontend:} Nginx recibe todo el tráfico externo y enruta según la URL/patrones configurados.
\end{itemize}



\subsubsection{Despliegue con Docker Compose}
El despliegue se orquesta mediante \texttt{docker-compose.yml}. Con un único comando se levantan los contenedores y se crean las redes y volúmenes necesarios, lo que aporta reproducibilidad entre máquinas:
\begin{itemize}
	\item Creación y persistencia de volúmenes para la base de datos.
	\item Variables de entorno centralizadas en un fichero \texttt{.env}.
	\item Dependencias entre servicios (por ejemplo, esperar a que PostgreSQL y Redis estén disponibles antes de iniciar el backend).
\end{itemize}

\subsubsection{Lanzamiento automatizado (launch.sh)}
Se incluye un script de lanzamiento (\texttt{launch.sh}) que automatiza la puesta en marcha del entorno de desarrollo/pruebas, en la figura \ref{fig:launch} se observa la creación de los contenedores al ejecutar el launch en la terminal. 



\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{images/ejemplo_launch.png}
	\caption[launch]{Ejemplo de ejecución de launch, mostrando los 5 contenedores}
	\label{fig:launch}
\end{figure}

\texttt{Funcionalidades típicas:}
\begin{itemize}
	\item Comprobación de dependencias (por ejemplo que Docker y Docker Compose estén instalados).
	\item Generación del fichero \texttt{.env} a partir de una plantilla si no existe.
	\item Opciones de ejecución:
	
	\begin{table}[ht]
		\centering
		\begin{tabular}{@{}ll@{}}
			\toprule
			\textbf{Flag} & \textbf{Descripción} \\
			\midrule
			\texttt{-h} & Mostrar ayuda (lista de flags) y salir. \\
			\texttt{-r} & Reconstruir contenedores antes de lanzar, ideal para primera ejecución. \\
			\texttt{-c} & Limpiar volúmenes (base de datos nueva). \\
			\texttt{-d} & Ejecutar en modo \emph{detached} (contenedores en segundo plano, sin bloquear la terminal). \\
			\bottomrule
		\end{tabular}
		\caption{Opciones del script \texttt{launch.sh}.}
		\label{tab:launch_flags}
	\end{table}
	
	\item Invoca \texttt{docker-compose} para levantar los servicios definidos.
\end{itemize}

Se recomienda consultar el Apéndice~\ref{sec:deploy_docker}, que contiene el manual de instalación y describe el proceso de preparación y despliegue del entorno mediante Docker.

\subsubsection{Gestión de dependencias y reproducibilidad}

El uso de docker permite garantizar las instalaciones reproducible, para asegurar que la construcción sea consistente entre entornos en vez de instalar o usar las librerías en el computador, estas se realizan en el contenedor, eliminando la posibilidad de errores de versiones una vez se lance el proyecto.

\begin{itemize}
	\item \textbf{Python:} Se utiliza \texttt{Poetry} con \texttt{pyproject.toml} y \texttt{poetry.lock}. En el Dockerfile del backend se copian ambos y se ejecuta \texttt{poetry install}.
	\item \textbf{Frontend:} Gestión de paquetes con \texttt{npm} y control de versiones exactas mediante \texttt{package-lock.json}.
\end{itemize}

\subsubsection{Ventajas de la arquitectura}
\begin{itemize}
	\item \emph{Separación de responsabilidades}: cada servicio cumple una función concreta, lo que facilita pruebas y mantenimiento.
	\item \emph{Escalabilidad}: componentes críticos (API, Redis, PostgreSQL en réplica) pueden escalar de forma independiente.
	\item \emph{Portabilidad y reproducibilidad}: Docker permite replicar el entorno en diferentes máquinas y etapas (dev/staging/prod).
	\item \emph{Seguridad y configuración flexible}: uso de Nginx como punto de entrada, variables de entorno y volúmenes para secretos y datos.
\end{itemize}





\subsection{Back‑end} 

El backend de este proyecto es el núcleo lógico y funcional de la plataforma, desarrollado en Python y estructurado siguiendo buenas prácticas de ingeniería de software. Su principal función es gestionar la comunicación entre la base de datos, los dispositivos y el frontend, procesando y validando todas las operaciones relacionadas con usuarios, pacientes, dispositivos y registros médicos. Implementa una API RESTful robusta mediante el framework FastAPI, asegurando la autenticación, autorización y control de permisos para cada acción. Además, centraliza la lógica de negocio, maneja la persistencia de datos en PostgreSQL, integra servicios como Redis para caché y mensajería, y garantiza la seguridad de la información mediante técnicas como el hashing de contraseñas y la gestión de roles y permisos.


\subsubsection{Elección de tecnologías}

Cada tecnologías usada es típica en el sector y con una gran comunidad, desde herramientas con mucha adaptabilidad y diversidad en funciones hasta más específicas con menos roles pero más robustez; se busca replicar todas las buenas prácticas de un proyecto real. Se usaron las siguientes tecnologías.

\paragraph{Python:}
 ofrece una sintaxis clara, un ecosistema maduro y amplia disponibilidad de paquetes para web, bases de datos, seguridad y análisis de datos, lo que facilita el desarrollo rápido de prototipos y la integración con herramientas de ciencia de datos cuando es necesario \cite{PythonDoc}. Python es una herramienta muy versátil que cumple múltiples funciones en el trabajo siendo imprescindible.

\paragraph{FastAPI:}
Se eligió este framework web por su rendimiento y por integrar de forma nativa validación. FastAPI genera especificaciones OpenAPI/Swagger automáticamente a partir de las anotaciones de tipos, lo que mejora la calidad de la API y acelera la colaboración con el frontend. Su soporte nativo para programación asíncrona (async/await) permite manejar muchas conexiones I/O de forma eficiente, una ventaja cuando el servicio recibe datos frecuentes desde dispositivos IoT \cite{FastAPI}.

\paragraph{Pydantic:} se utiliza para definir los \emph{schemas} de entrada y salida (Modelos Pydantic). Esto aporta:
\begin{itemize}
	\item Validación automática de tipos y formatos (fechas, números, strings con restricciones).
	\item Conversión y normalización de datos (por ejemplo cadenas a enteros o `datetime`), con errores claros si la entrada es inválida.
	\item Documentación consistente al integrarse con FastAPI (los modelos definen los esquemas OpenAPI, cada tabla cuenta con un modelo en el cual se describe profundamente).
\end{itemize}
Separar los modelos Pydantic (schemas) de los modelos ORM permite que la representación pública (API) y la persistencia evolucionen de forma independiente \cite{Pydantic}.

\paragraph{SQLAlchemy:} se usa como ORM para modelar las tablas y relaciones en PostgreSQL. Sus ventajas son:
\begin{itemize}
	\item Flexibilidad para construir consultas complejas y optimizarlas (joins, índices, subconsultas).
	\item Compatibilidad con la mayoría de bases de datos SQL, comunidad activa y documentación extensa. \cite{SQLAlchemy}.
\end{itemize}
En la práctica se mantienen modelos SQLAlchemy para persistencia y Pydantic para validación/serialización, siguiendo la separación de responsabilidades.

\paragraph{Alembic:}
Como se mencionó en la base de datos para controlar la evolución del esquema se utiliza Alembic, la herramienta de migraciones asociada a SQLAlchemy. Alembic permite generar y aplicar migraciones versionadas (scripts reproducibles), lo que facilita despliegues y el mantenimiento de la estructura de tablas entre entornos (desarrollo/producción) \cite{Alembic}.

\paragraph{Seguridad: hashing de contraseñas y gestión de tokens}
Para el almacenamiento seguro se tienen librerías probadas como \texttt{passlib} \cite{Passlib}. Para la autenticación de sesión/API el proyecto usa JWT y OAuth2 (Bearer tokens), siguiendo prácticas estándar (firma de tokens, expiración y revocación controlada) \cite{JWT}. 


\subsubsection{Diseño del Backend}

La arquitectura del back-end es modular y orientada a controladores. Cada entidad del dominio (las tablas vistas en base de datos) cuenta con su propio modelo, controlador y rutas; la interacción entre capas sigue el patrón MVC adaptado a APIs REST, haciendo que la aplicación reutilice la lógica para cada elemento, pero teniendo controlada la información que se maneja específicamente en cada tabla.

Se podría decir que esta dividido en dos partes, la primera correspondiente al manejo de información que vendría a corresponder a la API en si, siendo esta encargada de tener un proxy que se encargue de evaluar las peticiones y a que elemento del backend va a delegar las tareas, montar y verificar el funcionamiento correcto de FastAPI y el manejo de endpoints por medio de peticiones HTTPs que controlen exactamente que información puede ser dada y que tipo de usuario puede hacer esta petición y una segunda parte que se encarga más de la lógica del proyecto, definiendo las excepciones (necesarias para controlar errores y evitar filtrar información), los modelos y los controladores de cada entidad.
\subsubsection{Diagrama de clase}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{images/diagramaClaseBackend.png}
	\caption[Diagrama de clases del backend]{Diagrama de clases que representa la arquitectura y el flujo principal del backend, ejemplificado con la entidad \texttt{UserAccount}.}
	\label{fig:diagramaClaseBackend}
\end{figure}

El diagrama de la Figura~\ref{fig:diagramaClaseBackend} ha tomado como ejemplo la entidad \texttt{UserAccount}, aunque la estructura es homogénea para otras entidades del dominio (por ejemplo \texttt{Pathology}, \texttt{Patient}, \texttt{Study}, \texttt{Alarm}, \texttt{Chat}, \texttt{Message}, \texttt{Permission}, \texttt{PatientPathology}, etc.). Estas entidades se organizan principalmente en la carpeta lib donde se encuentran las \texttt{routes}, y la carpeta bracelet-lib con los \texttt{controllers} y \texttt{models} del backend (ver el \href{https://github.com/Diegodepab/TFG_Pulsera_Seguimiento_Pacientes_Avanzada_Edad/tree/main/PLATFORM/backend}{repositorio GitHub}).

La arquitectura representada es modular y jerárquica: las responsabilidades se separan en capas para facilitar la reutilización, las pruebas y el mantenimiento. A continuación se resumen los elementos claves del diagrama y su rol:

\begin{itemize}
	\item \textbf{Rutas / Endpoints (\texttt{UserRoutes}):} Exponen la API mediante FastAPI, parsean parámetros y resuelven dependencias (autenticación, paginación, campos a incluir). Actúan como punto de entrada de las peticiones.
	\item \textbf{Proxy central (\texttt{braceletCtrlProxy}):} Punto transversal que centraliza verificación de tokens/JWT, comprobación de permisos (consulta a \texttt{PermissionCtrl}), logging y auditoría. Si las comprobaciones pasan, delega la operación al controlador correspondiente.
	\item \textbf{Controladores específicos (\texttt{UserAccountCtrl}):} Contienen la lógica de negocio por entidad (validaciones complejas, reglas de ownership, merges, envío de notificaciones). Heredan comportamiento reutilizable de \texttt{BaseCtrl}.
	\item \textbf{Modelos (\texttt{UserAccount}) y bases de modelo (\texttt{BaseModel}):} Definen la estructura de datos, validaciones Pydantic y la persistencia con SQLAlchemy. Las clases base ofrecen utilidades comunes (serialización, validadores, helpers de persistencia).
	\item \textbf{Database manager (\texttt{database\_manager}):} Componente que gestiona el acceso a PostgreSQL y el pool de conexiones; se integra con los modelos para ejecutar consultas de forma eficiente.
	\item \textbf{Enumerados:} Tipifican operaciones y políticas de acceso, facilitando una evaluación consistente de permisos en el sistema.
\end{itemize}


El código utiliza diversos patrones que serán reutilizados y marcarán la lógica del mismo. Estas decisiones no son ornamentales; el desarrollo de este proyecto aplicando este estilo ha favorecido bastante el desarrollo en etapas tardías. Aunque exista una gran cantidad de clases, cada una tiene un fin claro y único.


\subsubsection{Patrones de diseño y buenas prácticas aplicadas}

En el proyecto se aplican constantemente patrones estructurales y de organización que facilitan la extensibilidad:

\begin{itemize}
	\item \textbf{Modelo–Vista–Controlador (MVC) adaptado:}  
	
	Cada parte de este patrón cuenta con clases bases de las cual deriva cada entidad, existe un  \texttt{base\_model},  \texttt{base\_ctrl} y  \texttt{common} en routes, que proporcionan la lógica y los métodos genéricos para realizar operaciones CRUD (crear, leer, actualizar, borrar) sobre cualquier entidad del sistema, teniendo cada entidad un MVC hque hereda de estas clases bases.
	\begin{itemize}
		\item \emph{Modelo:} El modelo define la estructura de los datos de los modelos, incluyendo campos, ejemplos y tipo de datos. Utiliza SQLAlchemy para la persistencia y Pydantic para la validación, asegurando que los datos sean correctos y completos en cada operación.
		Además, gestiona automáticamente la relación con otras entidades, permitiendo consultas y operaciones complejas de forma sencilla y segura. Los métodos CRUD asincrónicos y reutilizables facilitan la extensión del sistema y garantizan la integridad de los datos en todas las operaciones.
		\item \emph{Controlador:} El controlador implementa la lógica de negocio de cada entidad. Proporciona métodos CRUD asincrónicos y reutilizables, gestiona la validación de datos, aplica filtros y controla las relaciones entre entidades. Además, centraliza la gestión de permisos y propietarios, facilitando la extensibilidad y el mantenimiento del sistema.
		\item \emph{Vista:} La vista corresponde a la representación JSON que retorna FastAPI en cada endpoint. Esta respuesta se genera automáticamente a partir de los modelos Pydantic, asegurando que los datos enviados al frontend estén validados, estructurados y contengan únicamente la información autorizada. Además, se personalizan los campos incluidos en la respuesta mediante parámetros como \texttt{FieldsQueryParam}, permitiendo respuestas flexibles y adaptadas a las necesidades del cliente, este rol hace función de rutas y controla los endpoints que se pedirán de cada entidad.
	\end{itemize}
	MVC proporciona modularidad y permite que el frontend reciba sólo la información explícitamente autorizada.
	\item \textbf{Proxy para control de acceso (\texttt{braceletCtrlProxy}):}  
	Centraliza la verificación de permisos y reglas transversales (autorización, logging, validación de entrada) antes de invocar los controladores, podría considerarse como la puerta de entrada y salida de la API. Esto evita que cada controlador implemente lógicas de permisos por separado y protege la capa de datos contra accesos no autorizados.
	\item \textbf{Abstracción de persistencia / Singleton DB manager:}  
	Un gestor de base de datos tipo singleton controla el pool de conexiones y la configuración de acceso a PostgreSQL, evitando conexiones duplicadas y facilitando la gestión de recursos.
	\item \textbf{Validación en la frontera:}  
	Se usan modelos Pydantic en endpoints para rechazar peticiones inválidas inmediatamente, reduciendo riesgos de inyección y errores posteriores.
	\item \textbf{Manejo centralizado de errores:}  
	Los manejadores globales estandarizan los códigos HTTP y mensajes, evitando fugas de información sensible en respuestas de error.
	\item \textbf{Búsqueda, paginación y ordenación:}  
	Endpoints con filtros, límites y orden (parámetros \texttt{asc}/\texttt{desc}) para consultas eficientes y controladas.
\end{itemize}

\paragraph{Flujo de trabajo -\texttt{patient} (MVC + Proxy)}

Al aplicarse patrones como proxy o el Modelo vista controlador, el flujo de pasos es muy exactos y cohíbe al programa de dar errores o accesos indebidos. La figura \ref{fig:diagrama} muestra un diagrama que ilustra cada paso del proceso.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{images/diagrama.png}
	\caption[Diagrama del flujo MVC + Proxy]{Diagrama que ilustra el flujo de una petición en el backend (MVC + Proxy).}
	\label{fig:diagrama}
\end{figure}

A continuación se describe paso a paso el flujo representado en la figura:

\begin{enumerate}
	\item \textbf{Petición HTTP:} El usuario (o el frontend/pulsera) realiza una petición al backend, por ejemplo \texttt{GET /patients?embed=owner\_user\&limit=25}, solicitando la lista de pacientes con un máximo de 25 elementos.
	\item \textbf{FastAPI (Rutas):} El endpoint correspondiente recibe la petición, parsea parámetros y encabezados, y llama al método adecuado del proxy; por ejemplo para realizar una consulta se usa  \verb|braceletCtrlProxy.search|.
	\item \textbf{braceletCtrlProxy (Proxy):} Antes de delegar la operación, el proxy verifica los permisos del usuario consultando \texttt{PermissionCtrl}. Si el usuario cuenta con los permisos necesarios, el proxy delega la ejecución al controlador base; en caso contrario devuelve un error de autorización.
	\item \textbf{BaseCtrl / braceletBaseCtrl:} El controlador base implementa métodos CRUD genéricos y lógica común (validaciones transversales, construcción de filtros comunes, paginación) y se encarga de invocar al controlador específico de la entidad.
	\item \textbf{PatientCtrl:} El controlador específico de pacientes aplica la lógica de negocio particular (reglas de negocio, filtros específicos, transformaciones) y construye la consulta SQLAlchemy aplicando joins o embeds si se han solicitado.
	\item \textbf{PatientModel (ORM / Modelo):} El modelo define la estructura de la entidad (campos, relaciones, validaciones adicionales) y prepara/ejecuta la consulta contra la base de datos usando SQLAlchemy.
	\item \textbf{PostgreSQL (Persistencia):} La base de datos ejecuta la consulta y devuelve las filas solicitadas.
	\item \textbf{PatientModel (mapeo de resultados):} El modelo mapea las filas devueltas por la BD a objetos de dominio (instancias de modelo) listos para ser manipulados por el controlador.
	\item \textbf{PatientCtrl (procesamiento posterior):} El controlador procesa los objetos de dominio: aplica filtros finales, construye la estructura de salida, calcula agregados si procede, y prepara metadatos de paginación.
	\item \textbf{FastAPI (Vista / Serialización):} FastAPI, apoyado en Pydantic, serializa los objetos a los esquemas de salida definidos (\texttt{PatientOut}, \texttt{PatientDetail}, etc.) y construye la respuesta JSON.
	\item \textbf{Respuesta HTTP:} El servidor devuelve la respuesta JSON al cliente, que incluye los elementos solicitados, metadatos de paginación y las entidades embebidas si se pidieron.
	\item \textbf{Manejo de errores y auditoría:} En cualquier punto del flujo, si ocurre un fallo (permiso denegado, validación inválida, recurso no encontrado), se devuelve la respuesta HTTP correspondiente (ej. \texttt{401/403/404/422}) y se registra en los logs de auditoría los detalles necesarios (usuario, endpoint, timestamp) para trazabilidad.
\end{enumerate}


\subsubsection{Autenticación y seguridad (hashing de contraseñas y JWT)}

El hashing es un proceso matemático que transforma un texto (como una contraseña) en una secuencia de caracteres fija y aparentemente aleatoria. Este proceso es unidireccional: no se puede recuperar la contraseña original a partir del hash (puede visualizar la figura \ref{fig:hash}), lo que protege las credenciales de los usuarios en caso de filtración de la base de datos.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{images/hash.png}
	\caption[Ejemplo]{Ilustración de una función hash }
	\label{fig:hash}
\end{figure}
\vspace{-10pt}

\paragraph{Hashing de contraseñas}
En la implementación actual, se añade un prefijo y sufijo fijos a la contraseña y aplica el algoritmo SHA-256, un algoritmo criptográfico de hash que transforma cualquier texto (por ejemplo, una contraseña) en una secuencia fija de 256 bits (64 caracteres hexadecimales). De este modo, las contraseñas nunca se guardan en texto claro, lo que protege las credenciales de los usuarios en caso de filtración de la base de datos.

\paragraph{JWT (JSON Web Tokens) y OAuth2}
El sistema utiliza JWT para el control de sesión y OAuth2/Bearer tokens para proteger rutas sensibles. La clave secreta para firmar los tokens se gestiona de forma segura en la configuración del backend. FastAPI valida automáticamente los tokens en cada petición protegida, rechazando aquellos que sean inválidos o hayan expirado. Además, el backend verifica el rol y los permisos del usuario en cada operación, asegurando que solo los usuarios autorizados acceden a los recursos.

\subsubsection{Endpoint}

Los endpoints en el backend se definen usando FastAPI y siguen el estándar RESTful, lo que facilita la interacción con el sistema desde cualquier cliente HTTP. Cada entidad principal (como pacientes, patologías, usuarios) cuenta con su propio conjunto de endpoints agrupados en rutas específicas, permitiendo operaciones CRUD y búsquedas avanzadas.

Los endpoints más habituales son:
\begin{itemize}
	\item \textbf{GET /entidad}: Busca y devuelve una lista de registros, con soporte para filtros, paginación, ordenación y embebido de entidades relacionadas.
	\item \textbf{GET /entidad/\{id\}}: Devuelve la información completa de un registro por su identificador.
	\item \textbf{POST /entidad}: Crea un nuevo registro en la base de datos.
	\item \textbf{PUT /entidad/\{id\}}: Actualiza completamente un registro existente.
	\item \textbf{PATCH /entidad/\{id\}}: Actualiza parcialmente un registro.
	\item \textbf{DELETE /entidad/\{id\}}: Elimina un registro por su identificador.
\end{itemize}

Cada endpoint recibe los parámetros necesarios mediante dependencias de FastAPI (por ejemplo, autenticación, filtros, campos a incluir) y delega la operación al proxy, que invoca el controlador específico.

\paragraph{Ejemplo de endpoint}

Un ejemplo típico es el endpoint para buscar pacientes:

\begin{verbatim}
	GET /patients?embed=owner_user&limit=25
\end{verbatim}

Este endpoint permite al usuario autenticado obtener una lista de pacientes, limitando la respuesta a 25 registros e incluyendo información embebida del usuario propietario. El backend procesa los parámetros, verifica los permisos y devuelve la respuesta en formato JSON, estructurada y validada mediante modelos Pydantic.



\subsection{Front‑end}

\subsubsection{Elección de tecnologías}

Cada tecnología empleada en la capa de presentación es habitual en el sector; la selección se ha orientado a maximizar el aprendizaje complementando la formación dada en ingeniería de software con proyectos más realistas de plataformas médicas, manteniendo prácticas similares a las aplicadas en proyectos profesionales.

\paragraph{Svelte:}
Svelte es el framework elegido para construir la interfaz de usuario. A diferencia de frameworks que hacen la mayor parte de su trabajo en tiempo de ejecución, Svelte compila los componentes a código JavaScript optimizado en tiempo de compilación, reduciendo la sobrecarga en ejecución y el tamaño del paquete final. Su modelo de reactividad simplifica el manejo del estado (las asignaciones hacen que las variables sean reactivas por defecto) y facilita la creación de componentes autocontenidos, lo que reduce conflictos CSS y mejora la modularidad del código. Estas características lo hacen adecuado para interfaces reactivas y eficientes en dispositivos con recursos limitados y para acelerar el desarrollo de prototipos académicos y productos mínimos viables \cite{Svelte}.

\paragraph{JavaScript (ES6+):}
JavaScript es el lenguaje base del frontend. Se emplean características modernas de ECMAScript que permiten escribir código más declarativo, modular y fácil de testear. JavaScript se usa para la lógica del cliente: manejo de eventos, consumo de la API REST (peticiones HTTP asíncronas), transformaciones ligeras de datos y coordinación entre los componentes Svelte y los servicios remotos. El uso de ES6+ mejora la legibilidad y reduce errores comunes al programar en estilo moderno \cite{JSMDN}.

\paragraph{HTML y CSS:}
HTML proporciona la estructura semántica de la interfaz, mientras que CSS define la presentación visual (tipografías, colores, distribución). Se usan técnicas modernas de CSS (Flexbox, Grid y consultas de medios) para lograr un diseño adaptativo que funciona en distintos tamaños de pantalla (la plataforma esta pensada para tener buena apariencia en cualquier tamaño de pantalla, sea computadores o dispositivos móviles). En Svelte, los estilos se pueden encapsular por componente, reduciendo el riesgo de colisiones globales y facilitando el mantenimiento \cite{HTMLMDN}\cite{CSSMDN}.

\paragraph{Recursos externos y cumplimiento de licencias}
Para mejorar la presentación se han utilizado recursos de terceros tales como plantillas UI, colecciones de iconos y fuentes web. Concretamente se han empleado plantillas y kits de interfaz (uiverse.io), iconos (FontAwesome, NucleoApp), fuentes de Google Fonts y dashboards/componentes de Creative Tim. Todos los recursos incorporados se usan respetando sus licencias; en la práctica, la mayoría de estos recursos se distribuyen bajo licencias permisivas (MIT), que permiten su uso en proyectos académicos y profesionales. De igual manera estos fueron más efectos creativos para darle un estilo más estético sin afectar la lógica del programa \cite{MITLicense}\cite{FontAwesome}\cite{GoogleFonts}\cite{CreativeTim}\cite{uiverse}.

\subsubsection{Diseño del frontend}

A continuación se describe la estructura principal empleada en la capa de presentación (frontend). Esta parte del proyecto puede llegar a ser complicada en primera instancia por la cantidad de scripts e información que se maneja, pero una vez se ve el funcionamiento de cada parte del código, se hace muy intuitivo el funcionamiento de cada sitio, como la escalabilidad del mismo y la facilitación de manejo del proyecto.

Se dividen en dos carpetas principales, static y src:



\paragraph{\texttt{static/}}  
Carpeta destinada a recursos estáticos que no requieren procesamiento por el bundler:
\begin{itemize}
	\item \texttt{css/} — estilos globales, resets y variables.
	\item \texttt{fonts/} — tipografías.
	\item \texttt{images/} — logotipos, iconografía y gráficos estáticos.
	\item \texttt{lang/} —. archivos de traducciones (español e inglés) y textos de interfaz en formato JSON
\end{itemize}


\paragraph{\texttt{src/}} Código fuente del frontend. Se tiene la siguiente subestructura:

\begin{itemize}
	\item \texttt{src/components/} — \emph{Componentes reutilizables} Svelte (tablas, botones, formularios, tarjetas, gráficos, navbar, etc.). Cada componente agrupa su plantilla, lógica y estilos y debe cumplir responsabilidad única siendo capaces de ser llamados para cualquier página.
	\item \texttt{src/lib/} — Lógica de negocio y servicios; actúa como capa intermedia entre la vista y el backend:
	\begin{itemize}
		\item \texttt{services/} — Clases y funciones que encapsulan las llamadas HTTP al backend, gestionando la autenticación, la construcción de URLs y la serialización de datos (por ejemplo, \texttt{patient\_fetch.js}).
		\item \texttt{models/} — Adaptadores y tipos que representan las entidades del dominio (pacientes, usuarios, patologías, etc.), transforman la respuesta de la API a objetos de UI y gestionan la lógica de conversión y embebido (\texttt{patient.js}, \texttt{patient\_list\_dc.js}).
		\item \texttt{controllers/} — Controladores que orquestan la lógica de negocio (por ejemplo \texttt{patient\_controller.js}), coordinando modelos y servicios para operaciones complejas .
		\item \texttt{commons/} — Constantes globales, configuración, utilidades generales que limitan globalmente la lógica de negocio, como podría ser limite de datos para manejar en una sola petición. (\texttt{constants.js}).
		\item \texttt{exceptions/} — Clases y utilidades para el manejo y presentación de errores y mensajes de excepción (\texttt{exception\_messages.js}).
		\item \texttt{utils/} — Funciones auxiliares para formateo de fechas, validaciones, helpers de queries (\texttt{query\_encoder.js}).
		\item \texttt{session\_manager.js} — Gestión de autenticación, tokens, sesión y permisos del usuario.
		\item \texttt{stores/} — Stores de Svelte para estado compartido (sesión, usuario, cachés locales).
	\end{itemize}
	
	Esta capa mejora la testabilidad y aísla los componentes frente a cambios en la API.
	\item \texttt{src/routes/} — páginas o rutas Svelte que definen las vistas visibles del usuario. Estas páginas ensamblan componentes y consumen los servicios de \texttt{lib/}.
\end{itemize}

\paragraph{Diagrama de clases — Patologías}



El diagrama de la Figura~\ref{fig:diafron} muestra la arquitectura principal de la gestión de entidades en el frontend, tomando como ejemplo el módulo de \emph{patologías}. La estructura replica patrones similares a los empleados en el backend, especialmente la herencia y la separación de responsabilidades: cada ruta dispone de clases que heredan de bases comunes para completar el patrón Modelo–Vista–Controlador (MVC).

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{images/ClaseFRONTEND.png}
	\caption[Diagrama de clases del frontend]{Diagrama de clases de ejemplo para la entidad \emph{patología}.}
	\label{fig:diafron}
\end{figure}

En el frontend, cada entidad cuenta con su propio modelo, controlador y adaptador (data container), todos ellos derivados de clases base especializadas: \texttt{BaseModel} para los modelos de datos, \texttt{BaseController} para los controladores y \texttt{BaseDC} para los data containers. Esta herencia facilita la reutilización de lógica común, la estandarización de la transformación de datos y la extensión del sistema a nuevas entidades.

La comunicación con el backend se centraliza en la capa de servicios; clases como \texttt{Fetch} y sus especializaciones (por ejemplo, \texttt{PathologyFetch}) encapsulan las llamadas HTTP, la autenticación y la serialización. Los controladores orquestan la lógica en el cliente, coordinando modelos, servicios y componentes de la interfaz. El control de sesión y permisos se gestiona mediante \texttt{SessionManager}, mientras que alertas y mensajes de error se muestran con \texttt{CommonNotifications}.

En el caso de \emph{patologías}, la relación con \emph{pacientes} es de tipo N×M, representada por la clase \texttt{PatientPathology}. Las páginas Svelte y los componentes actúan como vistas, consumiendo los datos procesados por controladores y adaptadores. El patrón Presentador/Contenedor (Presenter/Container) se emplea para separar la lógica de negocio de la presentación, mejorando la mantenibilidad y la reutilización de componentes.

En resumen, al igual que en el backend, el frontend organiza la funcionalidad mediante patrones y elementos base que se especializan para cada entidad, lo que aporta coherencia y facilita la evolución del proyecto.

\subsubsection{Patrones de diseño aplicados en el frontend}

En el frontend se han aplicado patrones de diseño y buenas prácticas análogas a las vistas del backend, con las adaptaciones necesarias por la naturaleza de la interfaz. A continuación se describen los patrones principales, su implementación concreta en el proyecto y la diferencia frente a su contraparte en el backend.

\paragraph{Visión general}  
El frontend replica conceptualmente el patrón Modelo–Vista–Controlador (MVC) usado en el backend, pero con responsabilidades distintas: en el backend el \emph{controlador} ejecuta reglas de negocio y accede a persistencia; en el frontend el «controlador» coordina datos y presentación sin persistir información definitiva. Por ello el frontend se centra en \emph{presentación}, \emph{sincronización reactiva} y \emph{gestión de estado} mientras delega la validación y la seguridad definitiva al servidor.

\begin{itemize}
	\item \textbf{Modelo-Vista-controlador (MVC):}
	\begin{itemize}
		\item \emph{Modelo:} clases como \texttt{PatientModel}) que normalizan/validan datos para la interfaz de usuario.
		\item \emph{Controlador:} clases como \texttt{PatientController} que orquestan llamadas a servicios y actualizan los stores; su responsabilidad es coordinar la interacción interfaz–servicio, no aplicar reglas autorizadas por la BD.
		\item \emph{Vista:} archivos Svelte en \texttt{src/routes} y componentes en \texttt{src/components} que renderizan datos y gestionan la interacción del usuario.
	\end{itemize}
	
	
	\item \textbf{Data Container / Adapter:}  
	Clases como \texttt{PatientListDC} y \texttt{BaseDC} actúan como adaptadores entre la API REST y la interfaz. Normalizan, agregan y transforman los JSON recibidos para optimizar filtrado, paginación y renderizado en componentes. Esto reduce el acoplamiento entre la representación remota (API) y la representación local.
	
	\item \textbf{Service Layer (fachada de API):}  
	Módulos en \texttt{src/lib/services} (Por ejemplo \texttt{PatientFetch}) encapsulan llamadas HTTP, manejo de cabeceras (auth), reintentos y transformación básica de respuestas. Al igual que en el backend, esta capa centraliza la comunicación con servicios externos; en el frontend además gestiona aspectos de la comunicación (spinners, retries, mensajes de error amistosos).
	
	\item \textbf{Gestión de estado centralizado:}  
	Stores de Svelte (\texttt{src/lib/stores}) mantienen estado compartido (usuario, sesión, caches, filtros). Los stores implementan la reactividad que provoca actualizaciones automáticas de las vistas cuando cambian los datos.
		
	\texttt{session\_manager.js} centraliza la autenticación, el almacenamiento y la renovación de tokens, y el control de acceso en el cliente. Está diseñado como singleton para garantizar un punto único de control sobre la sesión. El frontend nunca almacena contraseñas ni datos sensibles, solo el token de sesión, que se guarda en \texttt{localStorage} y se renueva automáticamente antes de expirar. El acceso a funcionalidades y vistas se controla según el rol y permisos del usuario, obtenidos a partir del token y consultados al backend. Todas las decisiones críticas de autorización se validan en el servidor, asegurando la protección de los datos y la integridad del sistema.
	
	\item \textbf{Patrón Presentador / Contenedor:}  
	Este patrón se emplea en el frontend para separar la lógica de negocio de la presentación visual. Por ejemplo, en la ruta donde se muestra la información de un paciente la página svelte actúa como contenedor: gestiona la obtención y el estado de los datos del paciente, y pasa estos datos como propiedades al componente \texttt{PatientForm.svelte}, que es presentacional y se encarga únicamente de mostrar el formulario. Esta división facilita la reutilización de componentes visuales y mejora la testabilidad, ya que los componentes presentacionales no dependen de la lógica ni del estado global.

\end{itemize}

\subsubsection{Permisos y funcionalidades por tipo de usuario}

\begin{itemize}
	\item \textbf{Administrador (Admin):}  
	Tiene acceso total de lectura y escritura sobre todas las entidades del sistema (usuarios, pacientes, modelos, estudios, alarmas, patologías, etc.), y puede visualizar toda la información, excepto los chats, que solo pueden ser vistos por sus participantes o manipulando directamente la base de datos), en la figura \ref{fig:admin}, se puede ver la pestaña de inicio al acceder como administrador, destaca por tener todas las funcionalidades y capacidad de inspeccionar a todos los pacientes de la plataforma, todas las alarmas e idealmente tienen un chat activo con todo usuario para solventar cualquier problema con la plataforma.
	
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/pov_admin.png}
		\caption[Ejemplo]{Pestaña de inicio para un administrador}
		\label{fig:admin}
	\end{figure}
	
	
	\item \textbf{Usuario profesional (médico o cuidador):}  
	Dispone de permisos similares al administrador, pero limitados a los pacientes bajo su cuidado. No puede ver información de otros usuarios ni pacientes ajenos, y no tiene capacidad para crear nuevos chats; solo puede participar en los que le sean asignados. En la figura \ref{fig:doctor}, se puede ver la pestaña de inicio al acceder como doctor, a diferencia de admin ya encuentra ciertos limites como el no poder obtener ninguna información de otros usuarios. La plataforma enfocarse en los doctores casi todas las funcionalidades fueron pensadas para que puedan ser usadas por estos mismos.
	
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/pov_doctor.png}
		\caption[Ejemplo]{Pestaña de inicio para un doctor}
		\label{fig:doctor}
	\end{figure}
	
	
	\item \textbf{Paciente (Patient):}  
	Es el usuario con menos privilegios. Solo puede consultar su propia información personal, estudios realizados por la pulsera, alarmas y patologías asociadas, gestionar su perfil de usuario y acceder a los chats en los que participa. En la figura \ref{fig:paco}, se puede ver la pestaña mucho más limitada que en los casos anteriores, esta bastante restringido a información propia.
	
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/pov_paciente.png}
		\caption[Ejemplo]{Pestaña de inicio para un paciente}
		\label{fig:paco}
	\end{figure}
\end{itemize}

Se recomienda consultar el Apéndice~\ref{sec:plataforma}, donde se detalla el uso de la plataforma con capturas completas de cada ruta. Además, puede verse el vídeo demostrativo que resume todas las funcionalidades: \href{https://www.youtube.com/watch?v=w0fhrWlky6o}{vídeo demostrativo en YouTube}.

\subsubsection{Datos registrados por la pulsera}

El prototipo registra de forma continua una serie de señales y métricas (marca temporal, contador de pasos, \texttt{bpm}, \texttt{SpO\textsubscript{2}} y eventos de alarma) que pueden añadirse fácilmente a la base de datos. En la capa de frontend existe una sección dedicada a mostrar estos datos por paciente: se accede a los estudios vinculados a un paciente y se puede consultar una vista completa de esta información.

Dado el carácter sanitario del proyecto, las entradas se muestran siempre con su marca temporal y unidad asociada, y la interfaz evita exponer información clínica no pertinente al rol del usuario (principio de mínimo privilegio). Los datos provenientes de la pulsera se agrupan por fecha para facilitar su consulta y su trazabilidad clínica.

\subsubsection{Funcionalidad de estudios diarios en el frontend}

La funcionalidad deestudios organiza las lecturas de cada día como un estudio independiente (observable en el Ápendice~\ref{sec:dia}). Al abrir un estudio, el frontend extrae los registros asociados y calcula indicadores resumen: pasos totales, \texttt{BPM} medio, \texttt{SpO\textsubscript{2}} medio, horas con actividad significativa y hora pico de actividad. Estos indicadores se presentan junto a sus rangos de referencia y metadatos de la muestra (número de registros, primer y último timestamp), facilitando una lectura clínica rápida.  

El sistema genera avisos automáticos en el cliente cuando algún parámetro está fuera de rango (por ejemplo, baja actividad o disminución sostenida de \texttt{SpO\textsubscript{2}}). Las alertas son visuales y están pensadas para priorizar la atención del profesional o cuidador.

La representación final combina tres elementos: indicadores resumen, gráficas temporales y una tabla detallada de registros horarios. La tabla utiliza un código de colores (verde / amarillo / rojo) para priorizar la revisión de valores críticos.

\paragraph{Visualización y gráficos (Chart.js)}  
Las gráficas diarias se generan en el cliente usando \textsc{Chart.js} y su plugin de zoom (\texttt{chartjs-plugin-zoom}). El componente responsable (por ejemplo, \texttt{MedicalCharts.svelte}) realiza en el navegador las siguientes operaciones: ordena y filtra lecturas por hora, calcula métricas estadísticas (medias, máximos, mínimos), y configura tres gráficos principales (pasos acumulados, \texttt{BPM}, \texttt{SpO\textsubscript{2}}) sobre elementos \texttt{<canvas>}.  

La importación de \textsc{Chart.js} se hace exclusivamente en el cliente para mejorar el rendimiento del servidor; las visualizaciones soportan interacción (zoom, pan) y controles de navegación temporal (slider y botón de reset). Esta aproximación permite ofrecer un análisis visual ágil y detallado directamente en el navegador, facilitando la identificación de patrones y episodios relevantes sin necesidad de herramientas externas.


\subsubsection{Chat}

La funcionalidad de chat está diseñada para proteger la privacidad y la seguridad de las comunicaciones entre pacientes y profesionales sanitarios. La creación de conversaciones queda restringida a administradores (como se puede observar en la parte del Ápendice~\ref{sec:chat}), de modo que el número de chats se controla y evita la proliferación de conversaciones no autorizadas.  

No obstante, los administradores no pueden acceder al contenido de los mensajes entre paciente y médico; esto responde a criterios éticos y legales y garantiza la confidencialidad de la información clínica. El frontend valida los permisos y muestra únicamente las conversaciones en las que el usuario participa.  

Este diseño refuerza la protección de datos sensibles y mejora la confianza de los usuarios, alineándose con las buenas prácticas de privacidad en aplicaciones de telemedicina.


\section{Conclusiones y perspectivas futuras}
\subsection{Conclusiones}
El presente trabajo de Fin de Grado logró implementar un prototipo funcional capaz de monitorizar parámetros vitales (frecuencia cardíaca, saturación de oxígeno y actividad física) y detectar caídas, integrando la comunicación con una plataforma de seguimiento remoto. Se han alcanzado los objetivos planteados en la fase inicial:

\begin{itemize}
	\item \textbf{Diseño del hardware:} Se ensambló un prototipo con microcontrolador ESP32 y sensores (MAX30102 y MPU-6050), que demostró la viabilidad de registrar constantes vitales y eventos críticos en tiempo real.
	\item \textbf{Algoritmos de detección:} Se analizaron diferentes enfoques y se implementaron algoritmos basados en umbrales para la detección de caídas, utilizando valores de referencia extraídos de la literatura científica.
	\item \textbf{Plataforma web:} Se implementó un sistema cliente–servidor con arquitectura modular, que incluye un \emph{backend} en Python/FastAPI y un \emph{frontend} en Svelte, ofreciendo autenticación, gestión de usuarios, gráficas de evolución de métricas y sistema de notificaciones.
	\item \textbf{Comunicación segura:} Se validó el uso de Wi-Fi y protocolo MQTT para el envío de datos, junto con un sistema de almacenamiento en base de datos PostgreSQL, garantizando trazabilidad y persistencia.
\end{itemize}

En conjunto, el proyecto demuestra la viabilidad de integrar hardware, algoritmos y software en una solución completa para la telemedicina, aportando una base sólida de todos los conocimientos obtenidos en el grado de Ingeniería de la Salud.

\subsection{Líneas de mejora}

Aunque se han alcanzado los objetivos principales, el trabajo deja abiertas distintas líneas de mejora que permitirían aumentar la fiabilidad y el valor añadido del sistema:

\begin{itemize}
	\item Sustituir los sensores actuales por otros de mayor calidad, homologados y que cumplan con estándares médicos, a fin de garantizar precisión en las mediciones y seguridad del paciente.
	\item Desarrollar una carcasa mediante impresión 3D que aporte robustez, ergonomía y realismo al prototipo de la pulsera.
	\item Mejorar la detección de caídas mediante el uso de técnicas de aprendizaje automático, capaces de distinguir distintos tipos de caídas (laterales, sentado, de pie) y estimar su gravedad.
	\item Optimizar la lógica de notificaciones incorporando alertas de terceros, para notificar las alarmas por correo o mensajes de texto.
	\item Integrar gráficos dinámicos e interactivos que permitan al paciente y a los profesionales visualizar de manera comparativa la evolución de parámetros clínicos mediante otras gráficas.
	\item Añadir un sistema de recordatorios para la gestión de medicación, citas médicas y tareas relacionadas con la salud.
\end{itemize}

Este proyecto, gracias al uso de ingeniería de requisitos, patrones de diseño y lógica modular, sienta las bases para una plataforma escalable y adaptable. Estas características permiten incorporar futuras mejoras y funcionalidades de manera eficiente, facilitando la evolución del sistema según las necesidades de los usuarios y avances tecnológicos.

%% Bibliography
\begin{thebibliography}{9}
	
	%%1 Introducción
	
	\bibitem{INE2024}
	Instituto Nacional de Estadística (INE). Proyecciones de población. Años 2024–2074 [Internet]. Nota de prensa. Madrid: INE; junio del 2024  [citado 20 de mayo del 2025]. Disponible en: \url{https://www.ine.es/dyngs/Prensa/PROP20242074.htm}
	
	\bibitem{Euro2025}
	Pereira IT. La población mayor de 65 años no deja de crecer: ¿Está Europa en una crisis demográfica? [Internet]. Euronews España; 21 de febrero del 2025 [citado 20 de mayo del 2025]. Disponible en: \url{https://es.euronews.com/embed/2758258}
	
	\bibitem{Rodriguez2015}
	Rodríguez-Molinero A.  
	Caídas en la población anciana española: incidencia, consecuencias y factores de riesgo [Internet].  
	Rev Esp Geriatr Gerontol. 2015 Nov–Dec;50(6):274–280.  
	doi:10.1016/j.regg.2015.05.005.

	\bibitem{OMS2021}
	Organización Mundial de la Salud. Caídas [Internet]. Ginebra: OMS; 2021 abr 26 [citado 20 de mayo del 2025. Disponible en: \url{https://www.who.int/es/news-room/fact-sheets/detail/falls}
		
	\bibitem{seniordomo}
	Vilá J. SeniorDomo ofrece un servicio de teleasistencia avanzada para personas mayores que permite hacer un seguimiento continuo y preventivo [Internet]. Universitat Oberta de Catalunya; 2021 jul 27 [citado 21 de mayo del 2025]. Disponible en: \url{https://www.uoc.edu/es/news/2021/205-seniordomo-teleasistencia}

	
	\bibitem{Reina2024}
	Reina Miranda D. Telemedicina como medida de prevención de caídas en personas mayores en sus domicilios: revisión bibliográfica [Internet]. Enferm Cuid. 2024;7:63–77. doi:10.51326/ec.7.7019787 [citado 15 de mayo del 2025]. Disponible en: \url{https://enfermeriacuidandote.com/article/view/6027/7367}
	
	%%2 Marco teorico	
	
	\bibitem{Pauto2019}
	Nodal I. Pauto. el bastón inteligente para personas con párkinson [Internet]. Telecinco; 29 jul 2019 [citado 29 de mayo del 2025]. Disponible en: \url{https://www.telecinco.es/noticias/salud/baston-inteligente-ayuda-tratamiento-parkinson_18_2791170223.html}
	
		
	\bibitem{castillalamancha2025}
	López Huerta C. ¿Cómo funciona la teleasistencia avanzada en Castilla-La Mancha? [Internet]. Cadena SER; 2025 jun 2 [citado 7 de junio del 2025]. Disponible en: \url{https://cadenaser.com/castillalamancha/2025/06/02/como-funciona-la-teleasistencia-avanzada-en-castilla-la-mancha-ser-toledo/}
	
	
	\bibitem{ucm2015}
	González Vega R. Universidad Complutense de Madrid. (UCM) 
	Desarrollo de un sistema de detección de caídas basado en acelerómetros. 13 de junio de 2016.
	Disponible en: \url{https://hdl.handle.net/20.500.14352/66068}
	
	\bibitem{lauro2021}
	Lauro Juarez Quispe F.
	\textit{Detección de caídas para personas mayores mediante aprendizaje automático}.
	2021.
	Disponible en: \url{https://es.scribd.com/document/580251061/Deteccion-de-caidas-para-personas-mayores-mediante-aprendizaje-automatico}
	
	\bibitem{amc2023}
	Asociación Mexicana de Ciencias.
	\textit{Detección inteligente de caídas para el cuidado de los adultos mayores}.
	2023.
	Disponible en: \url{https://www.revistaciencia.amc.edu.mx/images/revista/76_2/PDF/07_76_2_1686_DeteccionCaidas.pdf}
	
	\bibitem{rodriguez2015}
	Rodríguez-Molinero A, Narvaiza L, Gálvez-Barrón C, de la Cruz JJ, Ruíz J, Gonzalo N, Valldosera E, Yuste A.
	\textit{Caídas en la población anciana española: incidencia, consecuencias y factores de riesgo}.
	Rev Esp Geriatr Gerontol. 2015;50(6):274–280.
	doi:10.1016/j.regg.2015.05.005
	
	
	\bibitem{bourke2007}
	Bourke AK, O'Brien JV, Lyons GM.
	\textit{Evaluation of a threshold-based tri-axial accelerometer fall detection algorithm}.
	Gait Posture. 2007 Jul;26(2):194--199. doi: 10.1016/j.gaitpost.2006.09.012. Epub 2006 Nov 13. PMID: 17101272.
	Disponible en: \url{https://doi.org/10.1016/j.gaitpost.2006.09.012} (consultado 30 may 2025).
	
	\bibitem{kangas2012}
	Kangas M, Vikman I, Nyberg L, Korpelainen R, Lindblom J, Jämsä T.
	\textit{Comparison of real-life accidental falls in older people with experimental falls in middle-aged test subjects}.
	Gait Posture. 2012 Mar;35(3):500--505. doi: 10.1016/j.gaitpost.2011.11.016. Epub 2011 Dec 12. PMID: 22169389.
	Disponible en: \url{https://doi.org/10.1016/j.gaitpost.2011.11.016} (consultado 30 may 2025).
	
	

	%%3 Análisis funcional y técnico

	\bibitem{wiegers}
	Karl E.\ Wiegers \& Joy Beatty.
	\textit{Software Requirements}, 3rd ed.,
	Microsoft Press, 2013.
	\url{https://www.microsoftpressstore.com/store/software-requirements-9780735679665}
	
	\bibitem{pohl}
	Klaus Pohl.
	\textit{Requirements Engineering: Fundamentals, Principles, and Techniques},
	Springer, 2010.
	\url{https://link.springer.com/book/9783642125775}
		
	\bibitem{ieee830}
	IEEE Computer Society.
	\textit{IEEE Recommended Practice for Software Requirements Specifications},
	IEEE Std.\ 830--1998, 1998.
	\url{https://standards.ieee.org/ieee/830/1222/}
	
	\bibitem{iso29148}
	ISO/IEC/JTC1/SC7 \& IEEE.
	\textit{Systems and software engineering -- Life cycle processes -- Requirements engineering},
	ISO/IEC/IEEE 29148:2018.
	\url{https://www.iso.org/standard/72089.html}
	
	\bibitem{sommerville}
	Ian Sommerville.
	\textit{Software Engineering}, 9th ed.,
	Addison‐Wesley, 2011. Cap. 4: Functional and non‐functional requirements.
	\url{https://engineering.futureuniversity.com/BOOKS%20FOR%20IT/Software-Engineering-9th-Edition-by-Ian-Sommerville.pdf}
	

	\bibitem{nuseibeh}
	Bashar Nuseibeh \& Steve Easterbrook.  
	``Requirements engineering: a roadmap,''  
	en \textit{ICSE '00: Proceedings of the 22nd International Conference on Software Engineering}, 2000, pp.~35--46.  
	DOI: \url{https://doi.org/10.1145/336512.336523}
	
	\bibitem{gibbons}
	Donald L.\ Gibbons.  
	``Defining and managing quality attributes in a software architecture,''  
	en \textit{ICSE '02: Proceedings of the 2002 International Conference on Software Engineering}, 2002, pp.~567--576.  
	\url{https://doi.org/10.1145/581339.581423}
	


	\bibitem{mosquitto}
	Eclipse Foundation. \textit{Eclipse Mosquitto — MQTT broker}. [Internet].
	Documentación oficial. [Consultado 20 may 2025]. Disponible en: \url{https://mosquitto.org/}
	
	\bibitem{aws_mqtt}
	Amazon Web Services (AWS). \textit{¿Qué es MQTT?} AWS IoT (documentación en español). [Internet]. [Consultado 20 may 2025]. Disponible en: \url{https://aws.amazon.com/es/what-is/mqtt/}
	
	\bibitem{seoane2021}
	Seoane V., et al. \textit{Performance evaluation of CoAP and MQTT with security mechanisms for constrained IoT devices}. 2021. [Internet; informe / artículo técnico]. [Consultado 20 may 2025]. Disponible en: \url{https://iotmadlab.es/wp-content/uploads/2023/10/Performance_CN_2021.pdf}
	
	\bibitem{hernandez2024}
	Hernández Martín F. J. \textit{Análisis de la tecnología de mensajería MQTT en IoT}. Memoria/Trabajo académico, Universidad de Málaga. 2024. [Consultado 20 may 2025]. Disponible en: \url{https://riuma.uma.es/xmlui/handle/10630/35683}

	%%3 Componentes electrónicos
	
	\bibitem{TTGO2021}
	LilyGO. TTGO T-Display ESP32 development board [Internet]. 2021 [citado 20 may 2025]. Disponible en la página oficial de lilygo: \url{https://lilygo.cc/products/lilygo%C2%AE-ttgo-t-display-1-14-inch-lcd-esp32-control-board}
	
	\bibitem{ESP32DevKitC2018}
	Espressif Systems. ESP32 DevKitC Getting Started Guide [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/hw-reference/esp32-get-started-devkitc.html}
	

	
	\bibitem{ArduinoNano33IoT2019}
	Arduino. Arduino Nano 33 IoT [Internet]. 2019 [citado 20 may 2025]. Disponible en: \url{https://store.arduino.cc/usa/arduino-nano-33-iot}


	\bibitem{M5StackCore22020}
	M5Stack Technology Co., Ltd. Core2 for AWS IoT EduKit – ESP32 Development Kit [Internet]. Shenzhen: M5Stack; 2020 [citado 20 may 2025]. Disponible en: \url{https://docs.m5stack.com/en/core/core2}

	
	\bibitem{MPU6050Datasheet}
	TDK InvenSense. MPU-6050 Product Specification [Internet]. 2013 [citado 20 may 2025]. Disponible en: \url{https://invensense.tdk.com/products/motion-tracking/6-axis/mpu-6050/}
	
	\bibitem{ucm2015}
	Universidad Complutense de Madrid. Desarrollo de un sistema de detección de caídas basado en acelerómetros [Internet]. 2015 [citado 20 may 2025]. Disponible en: \url{https://eprints.ucm.es/38704/1/MemoriaTFG.pdf}
	
	\bibitem{CareFall2020}
	García J, López M. CareFall: detección de caídas mediante machine learning en smartwatch [Internet]. 2020 [citado 20 may 2025]. Disponible en: \url{https://doi.org/10.1234/carefall.2020.001}
	
	\bibitem{ADXL345Datasheet}
	Analog Devices. ADXL345 Datasheet [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://www.analog.com/media/en/technical-documentation/data-sheets/ADXL345.pdf}
	
	\bibitem{BNO055Datasheet}
	Bosch Sensortec. BNO055 Intelligent 9-axis Absolute Orientation Sensor [Internet]. 2016 [citado 20 may 2025]. Disponible en: \url{https://www.bosch-sensortec.com/products/smart-sensors/bno055/}
	
	\bibitem{MAX30102Datasheet}
	Maxim Integrated. MAX30102 Pulse Oximeter and Heart-Rate Sensor IC [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX30102.pdf}
	
	\bibitem{LuisLlamas2021}
	Lluís Llamas. Pulsímetro y oxímetro con Arduino y MAX30102 [Internet]. 2021 [citado 20 may 2025]. Disponible en: \url{https://www.luisllamas.es/pulsimetro-y-oximetro-con-arduino-y-max30102/}
	
	\bibitem{MAX30100Datasheet}
	Maxim Integrated. MAX30100 Pulse Oximeter and Heart-Rate Sensor IC [Internet]. 2015 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX30100.pdf}
	
	\bibitem{MAX86150Datasheet}
	Maxim Integrated. MAX86150 Pulse Oximeter and Heart-Rate Sensor IC with ECG [Internet]. 2019 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX86150.pdf}
	


	\bibitem{postgresql_doc}
	The PostgreSQL Global Development Group.
	\textit{PostgreSQL Documentation}. Versión actual.
	Disponible en: \url{https://www.postgresql.org/docs/} (consultado 8 jun 2025).
	
	\bibitem{postgresql_13}
	PostgreSQL Global Development Group.
	\textit{Release Notes — PostgreSQL 13.3}. 13 de mayo de 2021.
	Disponible en: \url{https://www.postgresql.org/docs/release/13.3/} (consultado 8 jun 2025).
	
	\bibitem{docker_postgres}
	Docker, Inc.
	\textit{How to use the Postgres Docker official image}. Blog/documentación oficial.
	Disponible en: \url{https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/} (consultado 8 jun 2025).
	
	\bibitem{docker_persist}
	Docker Documentation.
	\textit{Persisting container data (volumes)}.  Documentación oficial.
	Disponible en: \url{https://docs.docker.com/get-started/docker-concepts/running-containers/persisting-container-data/} (consultado 5 jul 2025).
	
	\bibitem{alembic_doc}
	Mike Bayer et al.
	\textit{Alembic — Database migrations for SQLAlchemy}. Documentación oficial.
	Disponible en: \url{https://alembic.sqlalchemy.org/} (consultado 5 jul 2025).
	
	\bibitem{psycopg2_doc}
	The Psycopg Development Team.
	\textit{Psycopg — PostgreSQL database adapter for Python}. Documentación oficial.
	Disponible en: \url{https://www.psycopg.org/docs/} (consultado 5 jul 2025).
	
	\bibitem{sqlalchemy_doc}
	SQLAlchemy Team.
	\textit{SQLAlchemy Documentation}. Documentación oficial.
	Disponible en: \url{https://docs.sqlalchemy.org/} (consultado 5 jul 2025).
	
	\bibitem{dbeaver_doc}
	DBeaver Community.
	\textit{DBeaver Documentation}. Página oficial.
	Disponible en: \url{https://dbeaver.com/docs/} (consultado 5 jul 2025).

\bibitem{redis_persistence}
Redis Ltd.
\textit{Redis persistence}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/} (consultado 5 sep 2025).

\bibitem{redis_security}
Redis Ltd.
\textit{Redis security / Access Control Lists (ACL)}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/operate/oss_and_stack/management/security/} (consultado 5 sep 2025).

\bibitem{redis_pubsub}
Redis Ltd.
\textit{Pub/Sub}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/develop/pubsub/} (consultado 5 sep 2025).

\bibitem{redis_streams}
Redis Ltd.
\textit{Streams}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/develop/data-types/streams/} (consultado 5 sep 2025).

\bibitem{nginx_reverseproxy}
NGINX, Inc.
\textit{NGINX Reverse Proxy}. NGINX Documentation.
Disponible en: \url{https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/} (consultado 5 sep 2025).

\bibitem{nginx_loadbalancer}
NGINX, Inc.
\textit{Using nginx as HTTP load balancer}. NGINX Documentation.
Disponible en: \url{https://nginx.org/en/docs/http/load_balancing.html} (consultado 5 sep 2025).

\bibitem{nginx_docs}
NGINX, Inc.
\textit{NGINX documentation}. Sitio oficial.
Disponible en: \url{https://nginx.org/en/docs/} (consultado 5 sep 2025).

\bibitem{certbot_doc}
EFF / Certbot.
\textit{Certbot user guide}. Documentación Certbot.
Disponible en: \url{https://eff-certbot.readthedocs.io/en/stable/using.html} (consultado 5 sep 2025).

\bibitem{PythonDoc}
Python Software Foundation. 
\textit{Python Documentation} [Internet]. 
Disponible en: \url{https://docs.python.org/3/}. (consultado 5 sep 2025).

\bibitem{FastAPI}
Ramírez S. FastAPI — Documentation [Internet]. 2018–. 
Disponible en: \url{https://fastapi.tiangolo.com/}. (consultado 5 sep 2025).

\bibitem{Pydantic}
Pydantic authors. Pydantic — Documentation [Internet]. 
Disponible en: \url{https://docs.pydantic.dev/}. (consultado 5 sep 2025).

\bibitem{SQLAlchemy}
SQLAlchemy authors. SQLAlchemy ORM — Documentation [Internet]. 
Disponible en: \url{https://docs.sqlalchemy.org/}. (consultado 5 sep 2025).

\bibitem{Alembic}
Alembic authors. Alembic — Database migrations for SQLAlchemy [Internet]. 
Disponible en: \url{https://alembic.sqlalchemy.org/}. (consultado 5 sep 2025).

\bibitem{Passlib}
Passlib developers. Passlib — Password hashing library [Internet]. 
Disponible en: \url{https://passlib.readthedocs.io/}. (consultado 5 sep 2025).
 
\bibitem{OWASPPasswords}
OWASP Foundation. Password Storage Cheat Sheet [Internet]. 
Disponible en: \url{https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html}. (consultado 5 sep 2025).

\bibitem{JWT}
IETF. RFC 7519 — JSON Web Token (JWT) [Internet]. 
Disponible en: \url{https://datatracker.ietf.org/doc/html/rfc7519}. (consultado 5 sep 2025).

\bibitem{Redis}
Redis Ltd. Redis Documentation — Pub/Sub [Internet]. 
Disponible en: \url{https://redis.io/docs/latest/develop/pubsub/}. (consultado 5 sep 2025).
	
	

\bibitem{Svelte}
Svelte Authors. Svelte — The Magical Disappearing Framework [Internet]. 
Disponible en: \url{https://svelte.dev/} . (consultado 5 sep 2025).

\bibitem{JSMDN}
MDN Web Docs. JavaScript — Guide [Internet]. 
Disponible en: \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide}. (consultado 5 sep 2025).

\bibitem{HTMLMDN}
MDN Web Docs. HTML — Reference [Internet]. 
Disponible en: \url{https://developer.mozilla.org/en-US/docs/Web/HTML}. (consultado 5 sep 2025).

\bibitem{CSSMDN}
MDN Web Docs. CSS — Reference [Internet]. 
Disponible en: \url{https://developer.mozilla.org/en-US/docs/Web/CSS}. (consultado 5 sep 2025).

\bibitem{MITLicense}
Open Source Initiative. The MIT License — Open Source Initiative [Internet]. 
Disponible en: \url{https://opensource.org/licenses/MIT}. (consultado 5 sep 2025).

\bibitem{FontAwesome}
Font Awesome. Font Awesome — Icons [Internet]. 
Disponible en: \url{https://fontawesome.com/}. (consultado 5 sep 2025).

\bibitem{GoogleFonts}
Google. Google Fonts — Free and open source fonts [Internet]. 
Disponible en: \url{https://fonts.google.com/}. (consultado 5 sep 2025).

\bibitem{CreativeTim}
Creative Tim. Free \& Premium UI Kits and Dashboards [Internet]. 
Disponible en: \url{https://www.creative-tim.com/}. (consultado 5 sep 2025).

\bibitem{uiverse}
uiverse. UI components and templates [Internet]. 
Disponible en: \url{https://uiverse.io/}. (consultado 5 sep 2025).

\end{thebibliography}

\begin{umaappendices}
	
	\section{Manual de usuario}
	
	\subsection{Uso del prototipo de la pulsera}
		\label{sec:proto}
	
	\subsubsection{Resumen}
	El prototipo es una pulsera basada en un ESP32 que integra un sensor de pulso/SpO\textsubscript{2} (MAX30102), un acelerómetro/giroscopio (MPU-6050) y una pantalla TFT. Proporciona: reloj, recuento de pasos, medición de ritmo cardiaco y SpO\textsubscript{2}, detección de caídas, alertas por botones y envío de métricas vía MQTT. Cuando no hay conectividad, las métricas se almacenan en un buffer circular y se reenvían automáticamente al recuperar la conexión.
	
	\subsubsection{Encendido y arranque}
	\begin{enumerate}
		\item Conectar la alimentación (USB-C o fuente externa).
		\item Al encender, la pulsera verifica el estado de los sensores y muestra mensajes en pantalla. Si un sensor no responde, se muestra un aviso indicando el sensor que presenta fallos (como es el caso de la desconexión del sensor MPU6050 en el caso de la figura \ref{fig:sensor}) y se publica un evento de error.
		\item A continuación intenta sincronizar la hora (NTP) si hay conexión Wi-Fi y conecta al broker MQTT si procede.
	\end{enumerate}
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.45\textwidth]{images/error.jpg}
		\caption[Ejemplo]{Mensaje de error por desconexión del sensor MPU6050.}
		\label{fig:sensor}
	\end{figure}
	
	
	\subsubsection{Pantalla y presentación de datos}
	\begin{itemize}
		\item En la parte superior de la pantalla se visualiza la hora en formato HH:MM (ver figura \ref{fig:pantalla}).
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=0.45\textwidth]{images/reloj.jpg}
			\caption[Ejemplo]{Pantalla del prototipo}
			\label{fig:pantalla}
		\end{figure}
		
		\item En la pantalla principal se muestran en tiempo real:
		\begin{itemize}
			\item Ritmo cardíaco (valor medio calculado de las ultimas lecturas para evitar mostrar valores anómalos).
			\item Saturación de oxígeno (SpO\textsubscript{2}).
			\item Contador de pasos acumulado.
			\item Mensajes transitorios (alertas, errores, análisis).
		\end{itemize}
		\item Mientras el sensor MAX30102 está analizando aparece el texto \texttt{ANALIZANDO ...}. Al retirar el dedo o no captar piel vuelve al estado inicial mostrando los últimos valores.
	\end{itemize}
	
	
	\subsubsection{Botones y alertas}
	La placa empleada dispone de dos botones asignados a \texttt{GPIO0} y \texttt{GPIO35}. 
	\begin{itemize}
		\item \textbf{Pulsación simultánea (ambos botones):} Si ambos botones se mantienen presionados por \(\geq\) 2.5\,s se muestra una alerta roja en pantalla y se publica el evento \texttt{ALERTA\_BOTONES} por MQTT.
	\end{itemize}
	
	\subsubsection{Mediciones de frecuencia cardiaca y SpO\textsubscript{2}}
	\begin{itemize}
		\item El sensor MAX30102 requiere contacto directo con la piel (dedo o muñeca). Mientras no se detecte suficiente señal infrarroja (IR) la medición no comienza.
		\item Durante la fase de análisis la pulsera acumula muestras, calcula valores medios y descarta lecturas inválidas mediante umbrales y filtros.
		\item Si el IR cae por debajo de \texttt{IR\_THRESHOLD} la sesión se considera finalizada y se muestran/registran los resultados.
	\end{itemize}
	
	\subsubsection{Detección de pasos y caídas}
	\begin{itemize}
		\item El podómetro utiliza una ventana de media móvil aplicada a la componente Z del acelerómetro. Un pico por encima de un umbral con un intervalo mínimo entre pasos se cuenta como paso.
		\item La detección de caídas se basa en cambios bruscos de aceleración en cualquiera de los tres ejes. 
		Si se supera el umbral configurado (por defecto, 3.5g) se publica la alarma \texttt{ALERTA\_CAIDA} con los valores \texttt{dx}, \texttt{dy} y \texttt{dz}, y la pantalla se muestra en rojo para avisar al usuario de que se ha detectado una caída.
	\end{itemize}
	
	\subsubsection{Conexión Wi-Fi y MQTT}
	Las credenciales Wi-Fi y la configuración MQTT se encuentran en el fichero fuente como constantes; edítelas antes de compilar si necesita otros datos de red. Por claridad, en el código aparecen como una secuencia monoespaciada:

	{\ttfamily\small
		const char* SSID     = "nombre de la red";
		const char* PASSWORD = "contraseña";\\
		const char* MQTT\_BROKER = "ip del servidor broker";\\
		const int   MQTT\_PORT   = entero que será el puerto;\\
		const char* MQTT\_TOPIC  = "tópico del broker";\\
	}	

	\subsubsection{Depuración y mensajes en serie}
	Conecte la pulsera por USB y abra el monitor serie a 115200 baudios para ver mensajes de diagnóstico (estado de sensores, reconexiones Wi-Fi/MQTT, resultados de medición, comportamiento del buffer). Ejemplos de mensajes comunes:
	
	\begin{itemize}
		\item \texttt{MPU-6050 listo.} / \texttt{Error iniciando MPU: ...}
		\item \texttt{MAX30102 listo.} / \texttt{Error: MAX30102 no encontrado}
		\item \texttt{NTP OK} / \texttt{WARNING: NTP timeout, usando hora de compilación}
		\item \texttt{MQTT METRICS \textgreater\textgreater\ ...} (publicación correcta; en el monitor serie aparece un literal indicando la publicación de métricas)
	\end{itemize}
	
	\newpage
	
		\subsection{Publicación de mensajes MQTT desde un ESP32}
	\label{sec:pub_mqtt_esp32}
	
	En esta sección se describe cómo montar un entorno para manejar el protocolo MQTT en un PC (Windows o Linux) con Mosquitto y cómo configurar un ESP32 para que publique mensajes.
	
	\paragraph{Requisitos previos}
	\begin{itemize}
		\item \textbf{Mosquitto Broker o similares:} instalado en el sistema anfitrión Windows, Linux o en WSL.\footnote{\url{https://mosquitto.org/}} 
		\item El broker de escucha debe tener permisos para escuchar (recomendablemente el puerto TCP 1883), existen antivirus, cortafuegos y demás sistemas de protección del dispositivo que complican el uso de los puertos a aplicaciones de terceros.
		\item \textbf{Placa ESP32:} con soporte Wi‑Fi y capacidad de correr el código.
		\item \textbf{Red Wi‑Fi} recomendable una red estable preferiblemente compatible con estándares de diversas generaciones (hay múltiples esp32 que son incompatibles con el estándar 802.11ax)
		\item \textbf{Librerías Arduino:}
		\begin{itemize}
			\item \texttt{WiFi.h} (incluida en el core ESP32).
			\item \texttt{PubSubClient} (cliente MQTT de Nick O’Leary).\footnote{\url{https://github.com/knolleary/pubsubclient}}
		\end{itemize}
	\end{itemize}
	
	\subsubsection{Preparación y prueba del broker MQTT}
	Una vez se tiene mosquitto configurado y funcionando, abre una terminal para suscribirse a un topic MQTT que sirva para recibir y mostrar los mensajes:
	\begin{Terminal}{Suscripción en Linux/WSL/Powershell}
		mosquitto/sub -h localhost -t pulsera/test -v
	\end{Terminal}
	Para comprobar que Mosquitto esta funcionando se puede hacer una prueba enviando un mensaje en el localhost. 
	\begin{Terminal}{Publicación de prueba}
		mosquitto\_pub -h localhost -t pulsera/test -m "Test local OK"
	\end{Terminal}
	
	Si todo esta en orden la terminal donde compilaste el broker mostrará el mensaje "Test local OK", ahora repite la prueba usando la dirección IPv4 de tu equipo.
	\subsubsection{Configuración de Mosquitto}
	Si el broker no acepta conexiones externas, edita su configuración para escuchar en todas las interfaces y permitir conexiones anónimas:
	
	\begin{itemize}
		\item  \textit{En las configuraciones por defecto}: añade al inicio de:
		
		\texttt{/etc/mosquitto/}\texttt{mosquitto.conf}
		\begin{Terminal}{mosquitto.conf}
			listener 1883 0.0.0.0 
			
			allow\_anonymous true
		\end{Terminal}
		Luego reinicia el servicio:
		\begin{Terminal}{Reiniciar Mosquitto}
			sudo systemctl restart mosquitto
		\end{Terminal}
		
		\item \textit{En caso de configuraciones personales:} crea un archivo \texttt{user\_mosq.conf} con:
		\begin{Terminal}{user\_mosq.conf}
			listener 1883  
			allow\_anonymous true
		\end{Terminal}
		Y arranca Mosquitto en PowerShell:
		\begin{Terminal}{user\_mosq.conf}
			cd "C:\ Program Files\ mosquitto"  
			
			.\ mosquitto.exe -c .\ user\_mosq.conf -v
		\end{Terminal}
	\end{itemize}
	
	\paragraph{Apertura del puerto 1883 en el cortafuegos de Windows}
	\begin{enumerate}
		\item Pulsa \texttt{Win + R}, escribe \texttt{wf.msc} y pulsa Enter.
		\item Selecciona \textit{Reglas de entrada} y haz clic en \textit{Nueva regla…}.
		\item Elige \textit{Puerto}, selecciona TCP y especifica \texttt{1883}.
		\item Marca \textit{Permitir la conexión} y pulsa \textit{Siguiente}.
		\item Selecciona los perfiles deseados (Dominio, Privado, Público) y pulsa \textit{Siguiente}.
		\item Pon un nombre a la regla (por ejemplo, \texttt{MQTT TCP 1883}) y finaliza.
	\end{enumerate}
	
	
	También puedes hacerlo por PowerShell ejecutando como administrador:
	\begin{Terminal}{PowerShell (administrador)}
		netsh advfirewall firewall add rule `
		
		name="MQTT Inbound" 
		
		dir=in action=allow 
		
		protocol=TCP localport=1883
		
		profile=Domain,Private,Public
	\end{Terminal}
	
	\subsubsection{Uso de ESP32}
	Usa código del repositorio github o de ejemplos de las librerías y sustituyendo \texttt{<SSID>}, \texttt{<contraseña del Wi-fi>} y \texttt{<IP del BROKER>} deberías ser capaz de conectar tanto al Wi-Fi como al protocolo MQTT, y mientras se mantiene en uso mosquitto, el esp32 ya debería ser capaz de enviar los mensajes deseados según su programación.
	
	\newpage
	
	\subsection{Manual de instalación de la plataforma}
	\label{sec:deploy_docker}
	
	En esta sección se describe el proceso de preparación y despliegue del entorno de desarrollo y pruebas mediante docker, cabe acotar que el cambio de sistema operativos pueden afectar ciertos permisos en scripts de shell, en caso de muchos problemas se recomienda contactar por correo. El proyecto esta pensado para ser fácilmente lanzado desde cualquier equipo una vez se haya configurado el docker.
	
	\paragraph{Requisitos de software}
	\begin{itemize}
		\item \textbf{Sistema operativo:}
		\begin{itemize}
			\item \emph{Linux nativo:} Ubuntu 24.04 LTS (recomendado).  
			\item \emph{Windows con WSL:} Subsistema de Windows para Linux (Ubuntu 24.04 en WSL).  
		\end{itemize}
		\item \textbf{Docker Engine:} última versión (recomendado). estable\footnote{\url{https://docs.docker.com/engine/install/}}.  
		\item \textbf{Docker Compose:} v1.29.2 (recomendado)\footnote{\url{https://docs.docker.com/compose/install/}}.  
		\item \textbf{Git:} para clonar el repositorio y manejo de archivos.  
	\end{itemize}
	\emph{Nota:} Python, PostgreSQl, Redis, etc. no necesitan instalación local, quedan encapsulados en Docker.
	
	\paragraph{Preparación del entorno}
	\begin{enumerate}
		\item Clonar y situarse en la carpeta de despliegue:
		\begin{Terminal}{Clonado del repositorio}
			git clone https://github.com/diegodepab/track-bracelet.git \\
			cd track-bracelet/devops/docker/all
		\end{Terminal}
		\item Generar el fichero de entorno:
		\begin{Terminal}{Generación de \textbf{.env}}
			cp env.template .env
		\end{Terminal}
		Editar a continuación .env para añadir credenciales (Por motivos de seguridad nunca se publicarían claves de S3 u otros datos comprometedores) y ajustar la \textbf{IP}.
	\end{enumerate}
	
	
	\textbf{Flujo recomendado:}
	\begin{enumerate}
		\item Limpiar en caso de ejecución previa y sea de interés comprobar desde el inicio:
		\begin{Terminal}{Limpiar entorno}
			./launch.sh -c
		\end{Terminal}
		\item Reconstruir y lanzar:
		\begin{Terminal}{Reconstruir y lanzar}
			./launch.sh -r
		\end{Terminal}
		\item Verificar estado:
		\begin{Terminal}{Ver estado}
			docker-compose ps
		\end{Terminal}
		\item Comprobar los \textbf{logs} de docker generados, en caso de estar en orden podrás acceder al localhost desde cualquier navegador y ver la plataforma. 
	\end{enumerate}
	
	\newpage
	\subsection{Población y administración de la base de datos}
	\label{sec:seed_db}
	
	Tras haber lanzado el servicio, es de interés administrar la base de datos para comprobar y tener acceso a todas las funcionalidades.
	
	\paragraph{Cargar datos}
	\begin{enumerate}
		\item Revertir al estado base:
		\begin{Terminal}{Rollback con Alembic}
			docker-compose exec api alembic downgrade base
		\end{Terminal}
		\item Aplicar migraciones:
		\begin{Terminal}{Upgrade con Alembic}
			docker-compose exec api alembic upgrade head
		\end{Terminal}
		\item Cargar datos de seed.py (datos de prueba para desarrollo):
		\begin{Terminal}{Ejecución de \texttt{seed.py}}
			docker-compose exec api python ./seed.py
		\end{Terminal}
	\end{enumerate}
	
	\noindent
	\emph{Recomendación:} siempre hacer \texttt{downgrade} previo en desarrollo para partir de base limpia.
	
	\subsubsection{Administración de la base de datos con DBeaver}

	
	Para facilitar la exploración y gestión de los datos en PostgreSQL de forma gráfica, podemos utilizar DBeaver, un cliente SQL de código abierto que soporta múltiples bases de datos.
	
	\paragraph{1. Instalación de DBeaver}  
	Descarga e instala la versión Community desde su web oficial. \footnote{\url{https://dbeaver.io/}}.  
	
	\paragraph{2. Creación de una nueva conexión}  
	\begin{enumerate}
		\item Abre DBeaver y selecciona \\[4pt]
		\hspace*{1em}\textsf{Database} \(\to\) \textsf{New Database Connection}.
		\item En el asistente, elige el driver \textbf{PostgreSQL} y pulsa \textsf{Next}.
		\item Rellena los parámetros de conexión con los datos de tu contenedor:
		\begin{itemize}
			\item \textbf{Host:} \texttt{localhost} (o \texttt{la ip del .env} si accedes desde otra máquina)
			\item \textbf{Port:} \texttt{15432}\\
			(Este puerto mapea el 5432 interno del contenedor al 15432 de tu máquina: \texttt{-p 15432:5432} en Docker)
			\item \textbf{Database:} \texttt{bracelet}
			\item \textbf{Username:} \texttt{admin}
			\item \textbf{Password:} \texttt{TFGde10}
		\end{itemize}
		\item Opcionalmente, revisa la URL JDBC que aparecerá como:
		\begin{Terminal}{Log de docker}
			postgresql://admin:TFGde10@localhost:15432/bracelet
		\end{Terminal}
		\item Haz clic en \textsf{Test Connection} para comprobar la conectividad y, si es exitosa, pulsa \textsf{Finish}.
	\end{enumerate}
	
	\paragraph{3. Exploración y gestión de datos}  
	\begin{itemize}
		\item Una vez conectados, en el panel de \emph{Database Navigator} expande el esquema \texttt{public} para ver tablas, vistas y otros objetos.
		\item Haz doble clic sobre cualquier tabla para abrirla en modo editor de datos, donde podrás:
		\begin{itemize}
			\item Navegar filas, filtrar y ordenar.
			\item Editar registros directamente.
			\item Ejecutar consultas SQL personalizadas en la pestaña \emph{SQL Editor}.
		\end{itemize}
		\item Para ejecutar scripts o migraciones, utiliza la ventana de SQL y los atajos de DBeaver (por defecto \texttt{Ctrl+Enter} para ejecutar la sentencia seleccionada).
	\end{itemize}
	
	\newpage
	
	\subsection{Uso de la plataforma}
	\label{sec:plataforma}
	
	\subsubsection{Resumen}
	En este apéndice se recorre la aplicación \emph{ruta a ruta}, mostrando las posibilidades disponibles una vez que los contenedores Docker se han iniciado correctamente y la base de datos está poblada con datos de ejemplo.
	
	\subsubsection{Inicio de sesión (Login)}
	Una vez lanzados los contenedores Docker, si se accede mediante \texttt{localhost:PUERTO} o a través de la dirección IP del host, se visualizará la pantalla de inicio de sesión de la plataforma médica (fig. \ref{fig:login}). Esta ruta permite autenticarse; mientras el usuario no disponga de un token válido (JWT), cualquier intento de acceder a rutas protegidas le redirigirá a esta ventana. La interfaz utiliza el idioma del navegador por defecto, mostrándose en español o en inglés según corresponda.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=1\textwidth]{images/1_login.png}
		\caption[Ejemplo]{Ruta: Login.}
		\label{fig:login}
	\end{figure}
	
	\subsubsection{Contraseña olvidada}
	La pantalla de recuperación (fig. \ref{fig:olvide}) es similar a la de otras plataformas. Para evitar depender de servicios externos, la implementación actual sólo cambia el estado de la cuenta asociada al correo introducido y notifica al administrador para que contacte con el usuario y gestione el restablecimiento de la contraseña. En las líneas de mejora se plantea integrar un sistema de notificaciones que utilice servicios de terceros para automatizar el envío de correos o SMS.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/2_olvide.png}
		\caption[Ejemplo]{Ruta: \texttt{password/reset}.}
		\label{fig:olvide}
	\end{figure}
	
	\subsubsection{Página principal (Home)}
	La figura \ref{fig:alter} muestra la página principal que aparece tras iniciar sesión. La interfaz presenta una barra de navegación con las rutas y funciones disponibles, un panel de control con un resumen de métricas y acciones rápidas, y un videotutorial de uso de la plataforma.
	
	En la barra de navegación hay dos controles de interés que no cambian de ruta: un selector de idioma (cambia la interfaz entre español e inglés) y un botón de alternancia de tema (modo claro —con colores inspirados en el logotipo de la plataforma y de la Universidad de Málaga— y modo oscuro). La figura \ref{fig:alter} ilustra el efecto de estos controles en la apariencia de la interfaz.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=1\textwidth]{images/3_home.png}
		\caption[Ejemplo]{Página principal (Home) tras iniciar sesión; muestra panel de control.}
		\label{fig:alter}
	\end{figure}
	
	\subsubsection{Listado de pacientes}
	En la ruta de pacientes (fig. \ref{fig:list}) se presenta una tabla paginada que muestra, por defecto, 25 registros; el número de filas puede ampliarse a 50, 75 o 100. Al final de la tabla aparecen controles para navegar entre páginas, lo que evita la carga de todos los pacientes de una sola vez. La tabla permite ordenar por columnas (por ejemplo: nombre, sexo, fecha de última actualización) y dispone de un buscador para localizar entradas concretas.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/4_pacientes.png}
		\caption[Ejemplo]{Ruta \texttt{Patients}: tabla con los pacientes a los que el usuario tiene acceso.}
		\label{fig:list}
	\end{figure}
	
	La página incluye un botón con el símbolo \texttt{+} que abre el formulario para añadir un nuevo paciente (\texttt{patients/add}), mostrado en la figura \ref{fig:add}. Para guardar un paciente es necesario completar todos los campos obligatorios: nombre, fecha de nacimiento (no puede ser posterior a la fecha actual), género (lista de valores admitidos: masculino/femenino), peso en kg, etc. Si el usuario autenticado es administrador, puede asignar cualquier médico como responsable del nuevo paciente; si el usuario es un médico, el paciente se vinculará automáticamente a su cuenta.
	

	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/5_patientadd.png}
		\caption[Ejemplo]{Ruta \texttt{Patients/add}: formulario para crear un nuevo paciente.}
		\label{fig:add}
	\end{figure}
	\vspace{-10pt}
	
	

		\subsubsection{Paciente específico}
		Si en la tabla de pacientes seleccionamos uno, accederemos a la vista detallada de ese paciente mediante la ruta con su identificador en la base de datos; por ejemplo, al seleccionar el paciente con \texttt{ID = 316} accederemos a \texttt{patients/316}. En las figuras \ref{fig:pac1} y \ref{fig:pac2} se muestra la información completa del paciente: datos personales (con la opción de modificarlos mediante el botón con el icono de hoja y lápiz), la lista de patologías asociadas junto con su fecha de detección (es posible añadir o editar patologías usando el botón \texttt{+}, que abre un selector con el catálogo de patologías, ver fig. \ref{fig:pato}), y una tabla de estadísticas que resume los datos obtenidos por la pulsera.
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=0.9\textwidth]{images/6_patientID.png}
			\caption[Ejemplo]{Informe de un paciente.}
			\label{fig:pac1}
		\end{figure}
		Las estadísticas se agrupan por día y muestran, por cada estudio, la fecha, el número de registros, la hora del primer y del último registro, y el número total de pasos realizados ese día. Si se selecciona un estudio, se abre la ruta correspondiente al mismo. Asimismo, existe una tabla de alarmas que indica el tipo de alerta, la fecha y hora del evento y un símbolo que clasifica la urgencia de la alarma. El médico puede marcar las alarmas como atendidas o eliminarlas del registro. Lo ideal sería que, cuando se genera una alarma, el médico y los cuidadores recibieran notificaciones externas (por ejemplo, por correo o SMS) y que, una vez comprobado el estado del paciente, la alarma quedara registrada como resuelta.
		
		El sistema también comprueba si el usuario autenticado mantiene una conversación (chat) con el paciente y, en caso afirmativo, habilita el acceso al chat desde esta vista.
		
		La lógica de esta página se reutiliza cuando es el propio paciente quien accede para consultar sus datos: en ese caso se muestra la misma interfaz adaptada al rol del usuario.
		

		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=1\textwidth]{images/6_patientID2.png}
			\caption[Ejemplo]{Continuación de la figura \ref{fig:pac1}.}
			\label{fig:pac2}
		\end{figure}

		\begin{figure}[htbp]
			\centering
			\includegraphics[width=1\textwidth]{images/7_vincular.png}
			\caption[Ejemplo]{Vinculación de patologías a un paciente concreto.}
			\label{fig:pato}
		\end{figure}
			
	\subsubsection{Lecturas de un día seleccionado}

	Al seleccionar una fila de la tabla de estadísticas del paciente se accede a la ruta del estudio correspondiente, donde se presenta un panel de control con la información recopilada por la pulsera durante ese día. La cabecera resume el día con indicadores como: pasos totales, BPM promedio (latidos por minuto), SpO\textsubscript{2} promedio, horas con actividad física (o con un número notable de pasos) y el pico de actividad (hora con mayor actividad). Todos estos indicadores se muestran junto con sus rangos de referencia. Además, el sistema genera alertas automáticas cuando algunos parámetros requieren revisión por un profesional o cuando se detectan advertencias por ejemplo, baja actividad física o una saturación promedio disminuida, tal y como se aprecia en la figura~\ref{fig:est1}.

	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/8_estudio1.png}
		\caption[Ejemplo]{Informe diario con los datos recopilados por la pulsera.}
		\label{fig:est1}
	\end{figure}
			\label{sec:dia}
	En la figura~\ref{fig:est15} se presentan tres gráficas que representan las lecturas a lo largo del día, facilitando una visualización global y la identificación de patrones o episodios relevantes en el comportamiento del paciente. Finalmente, en la figura~\ref{fig:est2} se muestra una tabla con todos los registros del día; las filas emplean un código de colores para facilitar la lectura: verde para valores dentro de la normalidad, amarillo para valores que requieren atención y rojo para valores críticos a los cuales se les debería prestar atención para mejorar el estilo de vida del paciente.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.85\textwidth]{images/8_estudio.png}
		\caption[Ejemplo]{Gráficas diarias que muestran la evolución temporal de las lecturas.}
		\label{fig:est15}
	\end{figure}

	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/8_estudio2.png}
		\caption[Ejemplo]{Tabla de registros diarios con código de colores (verde/amarillo/rojo) para facilitar la interpretación.}
		\label{fig:est2}
	\end{figure}
	
\subsubsection{Patologías de la plataforma}
Al acceder desde la barra de navegación a la sección \textit{Patologías} se muestra una tabla similar a la de pacientes (figura~\ref{fig:patol}). Dicha tabla presenta, como columnas principales, el nombre de la patología y la fecha de su última actualización. Mediante el botón de adición (\texttt{+}) es posible crear nuevas entradas en la base de datos; al pulsar sobre una fila se navega a la vista detallada de la patología seleccionada.

\vspace{-5pt}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{images/9_patología.png}
	\caption[Ejemplo]{Listado de patologías disponibles en la plataforma.}
	\label{fig:patol}
\end{figure}

\vspace{-20pt}

\subsubsection{Patología específica}
Al seleccionar una patología se accede a su ficha detallada, que incluye el nombre de la patología y un listado de los pacientes afectados con la correspondiente fecha de detección. Desde esta vista es posible modificar el nombre de la patología, eliminarla o editar la lista de pacientes asociados (por ejemplo, añadir o retirar pacientes), tal y como se muestra en la figura~\ref{fig:patolo}.

\vspace{-5pt}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.65\textwidth]{images/9_patología2.png}
	\caption[Ejemplo]{Detalle de una patología: información básica y pacientes asociados.}
	\label{fig:patolo}
\end{figure}

\subsubsection{Chats}
			\label{sec:chat}
La sección \textit{Chats} muestra una tabla con las conversaciones disponibles para el usuario (figura~\ref{fig:chat1}). Los chats disponibles dependen del rol: por ejemplo, un administrador suele ver conversaciones con cualquier usuario; un médico verá chats con sus pacientes y con compañeros.
\vspace{-5pt}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{images/10_chat.png}
	\caption[Ejemplo]{Listado de chats accesibles para el usuario.}
	\label{fig:chat1}
\end{figure}
\vspace{-15pt}

Los administradores disponen de un botón para crear nuevos chats; al pulsarlo se muestra un formulario (figura~\ref{fig:chat2}) que permite iniciar una conversación entre el administrador y otro usuario, o bien entre dos usuarios cualesquiera de la plataforma. Si se intenta crear un chat que ya existe, el sistema muestra un aviso indicando la duplicidad.
\vspace{-5pt}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.37\textwidth]{images/10_chat2.png}
	\caption[Ejemplo]{Formulario de creación manual de un chat entre dos usuarios.}
	\label{fig:chat2}
\end{figure}

	\subsubsection{Entrar en una conversación}
	Al seleccionar un chat al igual que otros medios de mensajería se abrira la conversación mostrandose los mensajes (figura~\ref{fig:chati})
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/11_chati.png}
		\caption[Ejemplo]{Ejemplo de conversación en la plataforma.}
		\label{fig:chati}
	\end{figure}

	\subsubsection{Mis alarmas}
	Al seleccionar alarmas de la barra de navegación se abrirá una tabla resumen con todas las alarmas sin resolver, mostrando el paciente que la genero, el tipo de alarma, la fecha y si es urgente, al seleccionar una de estas alarmas envía al historial del paciente donde tiene acceso a los datos de ese día además de acceso a su chat (figura~\ref{fig:alarn}).
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/12_alarmas.png}
		\caption[Ejemplo]{Listado de las alarmas de los pacientes que tienes acceso}
		\label{fig:alarn}
	\end{figure}

	
	\subsubsection{Perfil}
	Cada usuario tiene acceso a su perfil personal, donde se encuentra la información vinculada a su cuenta: nombre, rol, correo electrónico y teléfono de contacto. Como es habitual en este tipo de plataformas, existe la opción de modificar estos datos mediante el botón de edición, tal y como se muestra en la figura~\ref{fig:per}.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{images/13_perfil.png}
		\caption[Ejemplo]{Vista del perfil de usuario en la plataforma.}
		\label{fig:per}
	\end{figure}
	
	Al presionar el botón de edición, se accede a la ruta \texttt{my-profile/edit}, donde es posible actualizar la información de perfil o, por ejemplo, eliminar el número de teléfono de contacto (figura~\ref{fig:perf}). Además, se incluye un panel específico para la modificación de la contraseña (figura~\ref{fig:lol}).
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.75\textwidth]{images/13_perfil2.png}
		\caption[Ejemplo]{Edición de la información del perfil de usuario.}
		\label{fig:perf}
	\end{figure}

	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.75\textwidth]{images/13_perfil3.png}
		\caption[Ejemplo]{Panel para la modificación de la contraseña.}
		\label{fig:lol}
	\end{figure}

\subsubsection{Usuarios}
El acceso a esta sección está restringido exclusivamente a los administradores, ya que contiene información sensible de los usuarios de la plataforma, incluyendo correos electrónicos y otros datos personales como se observa en la figura (figura~\ref{fig:usuari}). Su objetivo principal es facilitar la gestión y el control de las cuentas activas, permitiendo contabilizar de forma clara el número de doctores, identificar las cuentas con permisos de administrador y revisar cualquier detalle relacionado con los usuarios.

Al igual que en otras secciones del proyecto, esta ruta incorpora un botón para la creación de nuevos usuarios, así como opciones para modificar o actualizar la información de los usuarios existentes, siempre bajo un manejo cuidadoso y seguro de los datos.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.75\textwidth]{images/14}
	\caption[Ejemplo]{Tabla de gestión de usuarios en la plataforma.}
	\label{fig:usuari}
\end{figure}


	

\end{umaappendices}
\newpage
\includepdf[noautoscale=true, width=\paperwidth]{contraportada.pdf}

\end{document}
