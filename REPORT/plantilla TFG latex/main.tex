\documentclass[12pt, a4paper]{article}

%% Preamble
\usepackage{umatfgspanish}
\usepackage{blindtext}
\graphicspath{ {./images/} }

%% Packages using specific for this project
\usepackage{longtable}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{xurl}
\usepackage{textcomp} % para \textdegree y \texteuro
\usepackage[T1]{fontenc}


%— Coloreado con minted y cajas con tcolorbox —
\usepackage{tcolorbox}
\tcbuselibrary{minted,skins}

% Caja genérica para comandos de terminal
\newtcolorbox{Terminal}[2][]{%
	listing only,
	minted language=bash,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=black!75,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

% Entorno para código Python
\newtcolorbox{PythonCode}[2][]{%
	listing only,
	minted language=python,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=blue!50!black,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

% Entorno para código Java
\newtcolorbox{JavaCode}[2][]{%
	listing only,
	minted language=java,
	minted options={fontsize=\small,breaklines,autogobble},
	colback=black!5,
	colframe=red!50!black,
	fonttitle=\bfseries,
	title={#2},
	boxrule=0.5pt,
	arc=1mm,outer arc=1mm,
	leftrule=0.5pt,toprule=0.5pt,
	bottomrule=0.5pt,rightrule=0.5pt,
	before skip=1em,after skip=1em,
	#1
}

\begin{document}

\includepdf[noautoscale=true, width=\paperwidth]{cover.pdf}

\includepdf[noautoscale=true, width=\paperwidth]{title.pdf}


%% Abstract
\begin{abstract}
    

	{\bfseries\large Palabras clave:} 

\end{abstract}

%% Resumen
\section*{Abstract}

	
	
	{\bfseries\large Keywords:} 

\clearpage
\section*{Agradecimientos}

Apelando a la parte más humana de este trabajo, considero importante dejar constancia de aquellas personas que han sido fundamentales en mi crecimiento personal y acad\'emico durante estos a\~nos de universidad, y cuya influencia ha sido clave en la realizaci\'on de este Trabajo de Fin de Grado.

En primer lugar, quiero agradecer al personal acad\'emico de la universidad que muestra un esfuerzo e interés por ofrecer una formaci\'on de calidad. De forma especial, a mi tutor Cristian Mart\'in, a quien valoro profundamente tanto como docente como por su calidad humana. Junto a \'el profesores como Ismael Navas, Jos\'e Jerez, Rafael Luque, Rafael Larrosa, David Bueno, entre otros. Han contribuido significativamente a mi desarrollo intelectual y personal. Gracias a su dedicaci\'on, hoy reafirmo con alegría la decisi\'on de haber cursado esta carrera.

Tambi\'en quiero expresar mi gratitud a mis compa\~neros. Aunque ser\'ia imposible nombrar a todos, quiero destacar a Alejandro Silva y Mario Pascual, por su constante apoyo, por inspirarme a aspirar a más y por estar siempre presentes en los momentos clave de este recorrido.

En el \'ambito familiar, nada de esto habr\'ia sido posible sin el respaldo incondicional de mis padres y, especialmente, de mi hermano.

Quiero dedicar una menci\'on muy especial a mis abuelos, R\'egulo Depablos y Polia Moros, con quienes he compartido la evoluci\'on de este trabajo semana tras semana, como si ellos mismos fueran los pacientes. Con ellos he vivido la angustia de que un familiar sufra una caída y tener este TFG fue una oportunidad para tenerlos presentes en mi cabeza y darme cuenta de la importancia que tienen.

Finalmente, rindo homenaje a mi t\'ia Mireya Moros, quien falleci\'o este a\~no 2025. Aunque me pesa no haber podido visitarla en mi tierra natal, me reconforta saber que, a trav\'es de llamadas donde hablábamos de este trabajo, mi vida universitaria, etc. Se alegró de que la tuviera tan presente al hacer este trabajo con ella en mente. Y pude disfrutar con ella en sus últimos meses.

\vspace{1em}

Muchas gracias.

\tableofcontents

%% Sections
\section{Introducción}

	\subsection{Motivatión}
    
    El progresivo envejecimiento demográfico subraya la necesidad de soluciones tecnológicas orientadas a las personas mayores. En España, los mayores de 65 años representan actualmente el 20,4\% de la población total, cifra que, según el INE\cite{INE2024}, ascenderá a más del 30\% hacia mediados de siglo. A escala europea, la tendencia es similar: a principios de 2024, más de una quinta parte de la población de la UE tenía 65 o más años\cite{Euro2025}. Este panorama anticipa un incremento sostenido de las enfermedades crónicas y de la dependencia, acentuando la carga asistencial en hogares y centros sanitarios.
    
    Dentro de este colectivo vulnerable, las caídas suponen un grave problema de salud pública. En España viven unos 8,1 millones de personas ancianas, las cuales registran aproximadamente 4,3 millones de caídas al año, la mayoría de ellas en el propio domicilio\cite{Rodriguez2015}. Estudios recientes indican que alrededor de un tercio de los mayores de 65 años sufre al menos una caída anual, proporción que aumenta hasta el 50\% en mayores de 80. Del total de caídas, cerca del 9,3\% causan fracturas y más del 55\% requieren atención médica de urgencia. A nivel mundial, la Organización Mundial de la Salud destaca que las caídas son la segunda causa global de traumatismos accidentales (alrededor de 684 000 fallecimientos anuales) y que 37,3 millones de episodios de caídas exigen atención médica cada año; las tasas de mortalidad más altas corresponden a mayores de 60 años\cite{OMS2021}. Estos datos ilustran la magnitud del problema: las caídas en ancianos no solo comprometen la salud individual, sino que constituyen un reto para el sistema sanitario.
    
    Frente a este escenario, la tecnología \emph{wearable}, elementos como relojes, collares, etc. que se pueden llevar a todas partes, permitiendo monitorización continua y a distancia, surge como una solución prometedora. Funciones como detectar in situ caídas mediante acelerometría y, simultáneamente, registrar valores de interés para el seguimiento y mejora del paciente (frecuencia cardíaca, saturación de oxígenos y nivel de actividad física). De este modo se habilita un soporte permanente. Proyectos recientes respaldan esta aproximación: por ejemplo, La iniciativa privada Seniordomo ofrece un servicio de teleasistencia avanzada mediante wearable y monitoreo constante a través de una plataforma accesible para profesionales y pacientes\cite{seniordomo}. 
    
    El valor de esta tecnología se traduce además en mejoras concretas de calidad de vida. Al aumentar la seguridad del entorno, al sentirse acompañado a través de conexión permanente con familiares o servicios de salud. La persona mayor experimenta mayor tranquilidad y menor aislamiento\cite{Reina2024}. así como, al fomentar la autonomía domiciliaria (permitiendo quedarse más tiempo en casa pese a la fragilidad), se eleva la comodidad y el ánimo del anciano\cite{Reina2024}. Desde el punto de vista sanitario, disponer de registros continuos de datos biomédicos que se comparten con los profesionales facilita la detección temprana de signos de alerta y permite actuar de forma preventiva, asimismo obtener más información del paciente. En conjunto, estas prestaciones tecnológicas apoyan a los cuidadores, aligerando su carga y promoviendo un modelo de atención más proactivo y centrado en la prevención.
    
    El diseño de una pulsera con detección de caídas y monitorización de constantes vitales es una tecnología que cada vez cobrará mayor importancia. Permitirá abordar uno de los principales riesgos de salud en el envejecimiento poblacional, las caídas, reduciendo su impacto clínico y social. Esto, enfocado a la par con la telemedicina, ofreciendo un seguimiento de datos a cualquier paciente en el mundo, abarca una solución para una problemática que abarca cientos de millones de personas mayores alrededor del mundo.

	\subsection{Objetivos}
	
	\subsubsection{Objetivo general}
	Desarrollar un prototipo de pulsera acompañado de una plataforma de telemedicina, que permita el seguimiento remoto de parámetros vitales (frecuencia cardíaca, saturación de oxígeno y actividad física) y la detección de caídas en personas mayores.
	
	\subsubsection{Objetivos específicos}
	\begin{itemize}
		\item Diseñar un prototipo de la pulsera utilizando un microcontrolador, y sensores como pulsímetro, oxímetro, acelerómetro y giroscopio para la medición de constantes vitales y posibles caídas.
		
		\item Desarrollar algoritmos de detección de caídas basados en los datos obtenidos del acelerómetro y giroscopio, mediante la definición de umbrales y patrones que permitan diferenciar caídas.
		
		\item Implementar la plataforma de telemonitoreo:
		\begin{itemize}
			\item \textbf{Back-end (Python):} Servidor capaz de recibir, procesar y almacenar la información de la base de datos (postgreSQL) de manera segura.
			
			\item \textbf{Front-end (Svelte):} Interfaz web intuitiva destinada a médicos y cuidadores, que muestre toda la información necesaria del paciente, patologías, gráficas de evolución de parámetros vitales, notificaciones de alertas y  chat asegurando el mejor seguimiento.
		\end{itemize}
		
		\item Integrar la comunicación Wi-Fi de la pulsera, asegurando un flujo de datos seguro utilizando el protocolo MQTT.
		
		
	\end{itemize}

	
	\subsection{Estructura de la memoria}
	
	La memoria se encuentra dividida en los siguientes capítulos, cada uno de los cuales aborda de manera detallada los aspectos fundamentales del proyecto:
	
	\begin{itemize}
		\item \textbf{Capítulo 1 y 2: Introducción y marco teórico.}  
		En este primer capítulo se presenta el contexto general del Trabajo de Fin de Grado. Se describe la motivación que impulsa el desarrollo de una pulsera para el seguimiento de pacientes mayores, así como los objetivos generales y específicos del proyecto. Además, se incluye un breve análisis de precedentes y estudios relacionados, a su vez se evalúa la viabilidad técnica y económica.
		
		\item \textbf{Capítulo 3: Análisis funcional y técnico.}  
		En este capítulo se definen los requisitos del sistema, tanto funcionales como no funcionales. Se identifican los stakeholders principales y se analizan sus necesidades. Además, se realiza un estudio de riesgos.
		
		\item \textbf{Capítulo 4 y 5: Elección de alternativas y diseño de la pulsera (Hardware).}  
		\begin{itemize}
			\item \emph{Estudio de alternativas:} Se exponen las diferentes opciones de microcontroladores, sensores y baterías disponibles en el mercado que podrían cumplir con los requisitos definidos y se destaca las opciones elegidas.
			\item \emph{Diseño del esquemático:} Se detalla el esquema de la pulsera, señalando conexiones.
			\item \emph{Montaje físico y prototipado:} Se describe el proceso de soldadura y ensamblaje de componentes.  
			\item \emph{Desarrollo de código arduino} Se explica la estructura modular del firmware en lenguaje C++ para Arduino, detallando las tareas principales: inicialización, lectura de sensores, procesamiento de datos para detección de caídas y cálculo de parámetros de frecuencia cardíaca y SpO\textsubscript{2}, gestión de eventos de alerta y comunicación con la plataforma remota.  
			\item \emph{Protocolo MQTT:} Se justifica el uso de MQTT para la comunicación ligera entre la pulsera (cliente MQTT) y el servidor (broker MQTT), describiendo topologías de publicación/suscripción, calidad de servicio (QoS) y estrategias de reconexión ante pérdida de cobertura Wi-Fi.
			\item \emph{Pruebas del dispositivo:} Se muestra en rasgos generales el funcionamiento del prototipo, mostrando los resultados y su comportamiento ante eventos.
		\end{itemize}
		
		\item \textbf{Capítulo 6: Creación de la base de datos.}
		\begin{itemize}
			\item \emph{Uso de PostgreSQL:} Justificación breve de la elección, modo de empleo y herramientas a usar.
			\item \emph{Información que se desea manejar:} Resumen de familias de datos, desde que tipos de datos se desean tener y como se van a plantear en la base de datos.
			\item \emph{Modelo entidad-relación:} Diagrama lógico con las entidades principales.
		\end{itemize}
		
		\item \textbf{Capítulo 7: Desarrollo de la plataforma web.}  
		\begin{itemize}
			\item \emph{Arquitectura general del sistema:} Se describe la arquitectura cliente-servidor basada en microservicios, incluyendo la configuración de contenedores Docker para cada componente, la integración de Nginx como servidor web y proxy inverso, y el uso de Redis para caché y mensajería en tiempo real.
			\item \emph{Back-end (Python):} Se describen las tecnologías y frameworks elegidos (por ejemplo, FastAPI), la estructura de rutas RESTful, los modelos de datos para PostgreSQL y la lógica para procesar y almacenar las lecturas de la pulsera. También se documenta la implementación de mecanismos de autenticación y autorización para usuarios (médicos, familiares, cuidadores).  
			\item \emph{Front-end (Svelte):} Se explican las decisiones de diseño de la interfaz de usuario, enfocado en la usabilidad para pacientes y personal sanitario. Se incluyen los componentes principales: panel de control con gráficas de evolución de constantes vitales (frecuencia cardíaca, SpO\textsubscript{2}, pasos diarios), lista de alertas en tiempo real y formularios para configuración de umbrales y datos de contacto.  
		\end{itemize}
		


		
		\item \textbf{Capítulo 8: Conclusiones y perspectivas futuras.}  
		En este capítulo se recogen los resultados obtenidos tras la validación del prototipo: métricas de precisión en la detección de caídas, fiabilidad de las lecturas de frecuencia cardíaca y SpO\textsubscript{2}, rendimiento de la plataforma web y feedback obtenido de pruebas de usabilidad. Se analizan las limitaciones detectadas (consumo energético, cobertura Wi-Fi, ajustes en algoritmos de detección) y se proponen posibles mejoras, como la incorporación de baterías de mayor capacidad, algoritmos de inteligencia artificial para predicción de eventos críticos o la extensión de la plataforma a dispositivos móviles nativos.
		
		\item \textbf{Apéndice (Manual de uso).}  
		En el Apéndice se incluyen documentos de soporte para el usuario final y el equipo técnico:
		\begin{itemize}
			\item \emph{Manual de uso de la pulsera:} Ejemplo de uso del prototipo hardware, además de principales indicaciones y ejemplos de las funcionalidades.  
			\item \emph{Manual de uso de la plataforma web:} Ejemplo de uso de plataforma de telemedicina enfocando sus funciones y utilidades. 
			\item \emph{Guía de instalación del entorno de desarrollo:} Pasos detallados para desplegar la plataforma mediante Docker, configuración de variables de entorno.
			\item \emph{Población de la base de datos en entorno de desarrollo} Guía para poblar la base de datos mediante un script de profesionales de la salud y pacientes a partir de datos falsos, para probar la plataforma en un entorno de desarrollo.
			\item \emph{Preparación de un broker MQTT} Guía que describe como montar un entorno para manejar el protocolo MQTT en un PC (windows o linux) usando Mosquitto.
		\end{itemize}
	\end{itemize}
	

\section{Marco teórico}

	Es importante contextualizar y tomar de guía algunos de los proyectos que tienen una relación directa con la idea planteada, al ser una problemática de gran importancia se parte de una base ya explorada.

	\subsection{Ejemplos similares de dispositivos y teleasistencia médica}
	
	Actualmente existen múltiples propuestas para pulseras o equipos de seguimiento de pacientes de avanzada edad, el mayor problema de las soluciones es la dificultad en la globalización de un sistema que pueda ser adaptado a cualquier paciente.
	
	\subsubsection{SeniorDomo}
	
	SeniorDomo ofrece un servicio de teleasistencia avanzada para personas mayores que permite hacer un seguimiento continuo y preventivo. Utiliza un reloj para ofrecer múltiples funciones como detección de situaciones de riesgos (inactividad, pulso anómalo o caídas), botones de ayuda, localización GPS y permite procesar llamadas.  \cite{seniordomo}.
	
	\subsubsection{Bastón Pauto}
	
	Bastón Pauto enfocado en personas mayores con Parkinson y Alzheimer cuenta con un botón de emergencia y detección de caídas mediante la proyección láser de una línea verde y un punto rojo, combinado con la vibración de la empuñadura del bastón, permite que el usuario supere el episodio de bloqueo de la marcha cuando éste se produce. \cite{Pauto2019}.
	
	\subsubsection{Teleasistencia avanzada en Castilla-La Mancha}
	
	Además de iniciativas privadas también existen ejemplos como la Junta de Comunidades de Castilla-La Mancha que ha implementado un sistema de teleasistencia avanzada que atiende actualmente a más de 81.000 personas. Este sistema incluye dispositivos que detectan riesgos como caídas, incendios o escapes de gas, y utiliza inteligencia artificial para analizar rutinas y detectar alteraciones que puedan indicar situaciones de riesgo \cite{castillalamancha2025}.
	


	\subsection{Sistemas de detección de caídas existentes}


	La detección de caídas en personas mayores es un área de investigación activa, con múltiples enfoques tecnológicos desarrollados para abordar este problema de salud pública. A continuación, se describen algunos de los sistemas más relevantes:
		
	\subsubsection{Sistemas basados en umbrales}

	
	Estos sistemas utilizan acelerómetros para monitorizar los movimientos del usuario y detectar patrones que indiquen una caída. La detección se basa en establecer umbrales específicos de aceleración que, al ser superados, activan una alerta. Por ejemplo, en un TFG de la UCM sobre el desarrollo de un sistema de detección de caídas basado en acelerómetros se evalúa la magnitud máxima del vector de aceleración, calculada como:
	
	\[
	|\mathbf{a}| = \sqrt{a_x^2 + a_y^2 + a_z^2}
	\]
	
	donde \(a_x\), \(a_y\) y \(a_z\) son las componentes de aceleración en los ejes ortogonales X, Y y Z. Según los datos empíricos del estudio, las caídas provocan picos transitorios de aceleración de hasta 12 g, mientras que el valor mínimo de aceleración observado en una caída es de aproximadamente 3 g. Las actividades de la vida diaria (ADL) raramente superan los 3 g, aunque movimientos bruscos como correr o sentarse rápidamente pueden acercarse a este umbral. Debido al solapamiento entre los rangos de aceleración de caídas y ADL, el umbral de detección debe ajustarse cuidadosamente a cada paciente para minimizar falsos positivos y garantizar la robustez del algoritmo \cite{ucm2015}.
	
	\subsubsection{Sistemas basados en aprendizaje automático}
	
	El aprendizaje automático permite mejorar la precisión en la detección de caídas al analizar patrones complejos de movimiento. Un sistema desarrollado utiliza datos de sensores como acelerómetros para calcular características que luego son clasificadas por algoritmos como SVM o árboles de decisión, alcanzando una precisión del 96\% en la detección de caídas \cite{lauro2021}.
	
	
	\subsection{Medición de constantes vitales en wearables}
	
	Los dispositivos wearables han evolucionado para incluir sensores que permiten la monitorización continua de constantes vitales, lo cual es especialmente útil en la atención de personas mayores. Algunos de los parámetros comúnmente medidos incluyen:
	
	\begin{itemize}
		\item \textbf{Frecuencia cardíaca:} Utilizando sensores ópticos (fotopletismografía), los wearables pueden medir la frecuencia cardíaca en tiempo real.
		\item \textbf{Saturación de oxígeno (SpO\textsubscript{2}):} A través de sensores similares a los utilizados en pulsioxímetros, se puede estimar la saturación de oxígeno en la sangre.
		\item \textbf{Actividad física:} Los acelerómetros y giroscopios integrados permiten registrar la cantidad y tipo de actividad física realizada por el usuario.
	\end{itemize}
	
	La integración de estos sensores en dispositivos como pulseras inteligentes facilita el seguimiento remoto de la salud de los pacientes, permitiendo intervenciones tempranas y mejorando la calidad de vida de las personas mayores \cite{rodriguez2015}.


\section{Análisis funcional y técnico}
	
	Durante el transcurso de la carrera universitaria ingeniería de la salud otorga múltiples herramientas, conocimientos y capacidades para enfrentarse a diversos retos, no obstante de las cualidades más importantes es la correcta aplicación de ingeniería de requisitos.

	La especificación y gestión de requisitos es clave para el éxito de proyectos multidisciplinarios de informática e IoT, al facilitar la comunicación entre stakeholders y mejorar la calidad del sistema final \cite{wiegers, pohl}. Para garantizar especificaciones claras y trazables, se adoptan las buenas prácticas propuestas en IEEE 830–1998 y la norma ISO/IEC/IEEE 29148 \cite{ieee830, iso29148}.
	
		\subsection{Metodología de diseño}
		Para el desarrollo de este proyecto se ha optado por una \emph{metodología de diseño iterativo}, un enfoque cíclico que combina fases sucesivas de análisis, diseño, implementación y evaluación, de forma que cada iteración entrega un módulo funcional susceptible de validación y ajuste temprano \cite{wiegers,iso29148}. Este proceso permite detectar y corregir errores de manera precoz, incorporar cambios en los requisitos con agilidad y entregar incrementos de valor continuo, mejorando la adaptabilidad.
		
		Además, la naturaleza modular de cada iteración fomenta buenas prácticas de ingeniería de software, tales como la alta cohesión y el bajo acoplamiento, al dividir el sistema en componentes independientes que pueden desarrollarse y probarse en paralelo. La retroalimentación al iterar garantiza que el producto evolucione alineado a las necesidades reales, optimizando recursos y asegurando una mayor calidad final \cite{wiegers}.
	
		\subsection{Requisitos}
		
		Un requisito es una condición o capacidad que el sistema debe satisfacer para cubrir las necesidades de usuarios y partes interesadas. Se clasifican en funcionales, describen lo que el sistema debe hacer, y no funcionales, atributos de calidad del sistema. \cite{sommerville}.
	
			\subsubsection{Requisitos funcionales}
			
			Los requisitos funcionales definen los servicios y comportamientos que el sistema debe ofrecer para cumplir sus objetivos \cite{ieee830}. En este proyecto, los requisitos se describen mediante los siguientes atributos:
			
			\begin{itemize}
				\item \textbf{ID:} Código único que identifica el requisito (e.g., RF1).
				\item \textbf{Descripción:} Enunciado breve de la función a realizar.
				\item \textbf{Obligatoriedad:} “Obligatorio” u “Opcional” según prioridad de implementación.
				\item \textbf{Dependencia:} Requisitos previos necesarios para su correcto funcionamiento.
				\item \textbf{Trazabilidad:} Referencia a la sección del documento donde se detalla.
			\end{itemize}

			
			\begin{table}[ht]
				\centering
				\caption{Principales Requisitos Funcionales}
				\begin{tabular}{|p{1.5cm}|p{6cm}|p{2cm}|p{2cm}|p{3cm}|}
					\hline
					\textbf{ID} & \textbf{Descripción} & \textbf{Oblig.} & \textbf{Depend.} \\
					\hline
					RF1 & Registro de usuarios por rol (administrador, médico, paciente). & Obligatorio & —    \\
					\hline
					RF2 & Manejo de tokens y credenciales.                       & Obligatorio & RF1 \\
					\hline
					RF3 & Visualización de datos del paciente. & Obligatorio & —    \\
					\hline
					RF4 & Almacenamiento y consulta de datos en la base de datos.         & Obligatorio & - \\
					\hline
					RF6 & Manejo de alertas             & Obligatorio & RF3  \\
					\hline
					RF7 & Mensajería entre los usuarios.                              & Opcional   & RF1 \\
					\hline
					RF8 & Gestión del perfil.               & Opcional & RF1 \\
					\hline
				\end{tabular}
			\end{table}
	
	
	
		\subsubsection{No funcionales}
		
		Los requisitos no funcionales establecen las propiedades de calidad que el sistema debe cumplir \cite{ieee830}.
		
		\begin{table}[ht]
			\centering
			\caption{Principales requisitos no funcionales}
			\label{tab:req-no-funcionales}
			\begin{tabular}{|c|p{6cm}|c|c|c|}
				\hline
				\textbf{ID} & \textbf{Descripción} & \textbf{Oblig.} & \textbf{Depend.}  \\
				\hline
				RNF1 & Autonomía entre pulsera, base de datos y plataforma. & Obligatorio & RF4 \\
				\hline
				RNF2 & Implementación de lógica modular facilitando sustitución de piezas. & Obligatorio & -  \\
				\hline
				RNF3 & Simplicidad en la plataforma. & Opcional & RF3\\
				\hline
				RNF4 & Cifrado de datos personales. & Obligatorio & RF2, RF4 \\
				\hline
			\end{tabular}
		\end{table}

	
		\subsection{Análisis de riesgo}
		Al implementar un proyecto multidisciplinario con hardware, firmware y plataforma web, existen riesgos clave que deben gestionarse para asegurar el éxito. El siguiente cuadro resume los principales riesgos, su probabilidad e impacto, y las estrategias de mitigación.
		
		\begin{table}[ht]
			\centering
			\caption{Análisis de Riesgos del TFG}
			\begin{tabular}{|p{1cm}|p{5cm}|p{3cm}|p{6cm}|}
				\hline
				\textbf{Id} & \textbf{Descripción} & \textbf{Probabilidad / Impacto} & \textbf{Mitigación} \\
				\hline
				R1 & Dedicación y plazos insuficientes para cubrir todo el trabajo. & Alta / Media & Definir un cronograma detallado; priorizar tareas críticas; revisiones periódicas de avance. \\
				\hline
				R2 & Sensores de baja calidad generan datos poco fiables. & Muy alto / Bajo & Modularizar el diseño para facilitar su sustitución. \\
				\hline
				R3 & Vulnerabilidades en la seguridad y privacidad de datos. & Bajo / Alto &  Cifrado en base de datos; cumplir normativas de protección de datos. \\
				\hline
				R4 & Problema de producción de la pulsera & Alto / Muy Bajo & Centrarse en un prototipo funcional sin enfocarse en la ergonomía \\
				\hline
			\end{tabular}
		\end{table}
	
		\subsection{Stakeholders}
		
		Un stakeholder (o parte interesada) es cualquier persona, grupo u organización que tiene un interés o impacto directo en el proyecto.
		
		\begin{table}[ht]
			\centering
			\caption{Stakeholders Principales}
			\begin{tabular}{|p{3cm}|p{6cm}|p{7cm}|}
				\hline
				\textbf{Nombre} & \textbf{Representa} & \textbf{Rol} \\ 
				\hline
				Administrador (Desarrollador de software) &
				Responsable de la implementación y mantenimiento del firmware de la pulsera y la plataforma web. &
				Configura funcionalidades, garantiza la integridad de los datos y la comunicación entre dispositivo y servidor. \\
				\hline
				Personal médico &
				Profesionales de la salud que atienden a pacientes con riesgo cardíaco o de edad avanzada. &
				Monitorean constantes vitales y caídas, reciben alertas y ajustan tratamientos en tiempo real. \\
				\hline
				Paciente &
				Usuario final que lleva la pulsera para seguimiento. &
				Registra su actividad y constantes, consulta resultados, recibe alertas y comunica síntomas al médico. \\
				\hline
			\end{tabular}
		\end{table}
	
	\section{Elección de componentes electrónicos}
	
	
	En el mercado existen numerosas opciones que cumplen los requisitos de este proyecto, un microcontrolador con conectividad Wi-Fi y sensores capaces de medir aceleraciones para detección de caídas, así como señales ópticas para frecuencia cardíaca y saturación de oxígeno. A continuación se justifica la elección de cada componente para el caso del prototipo, pero en el trabajo se favorece lógica modular que permita el futuro cambio de componentes en caso de necesitar trabajar con mejores sensores.
	
	\subsection{Microcontroladores IoT}
	
	Para el prototipo de la pulsera se ha seleccionado la placa \textbf{TTGO T-Display (16\,MB)} (ver figura \ref{fig:ttgo_tdisplay_pines}) basada en el módulo ESP32. Este microcontrolador de bajo coste resulta ideal por integrar, en un único módulo, una pantalla TFT de 1.14\,\textquotedbl{} (135×240 px), gestión de batería Li-Ion y la inclusión de conectividad inalámbrica permite la transmisión de datos, mientras que la pantalla facilita una interfaz amigable para el usuario sin hardware adicional\cite{TTGO2021}.
	
	\noindent\textbf{Este módulo permite \cite{TTGO2021}:}
	\begin{itemize}
		\item \textbf{MCU:} ESP32 Xtensa dual-core LX6 (240 MHz). Este procesador de alto rendimiento permite gestionar en paralelo la adquisición de datos de sensores y la actualización de la interfaz gráfica.
		\item \textbf{Memoria Flash:} 16 MB, preferible para mostrar un interfaz con fondo de pantalla animado y capacidad de almacenaje de datos.
		\item \textbf{Pantalla:} 1.14 pulgadas, ST7789V IPS TFT, 135×240 px, 260 PPI, interfaz SPI
		\item \textbf{Conectividad inalámbrica:} Wi-Fi 802.11 b/g/n y Bluetooth 4.2 + BLE, esenciales para la transmisión de datos a la plataforma.
		\item \textbf{Alimentación:} 3.3 V, circuito de carga Li-Ion TP4054 y detección de nivel de batería, garantizando autonomía y avisos de carga.
		\item \textbf{Periféricos:} 2 botones (Ver figura 1, GPIO L006 e I007) configurables como botones de emergencia, y capacidad para integrar sensores adicionales.
	\end{itemize}
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=1\textwidth]{images/TTGO_T-Display.jpg}
		\caption[Diagrama de pines de la TTGO T-Display]{Diagrama de la placa \mbox{TTGO T-Display (16\,MB)} con todos sus pines de conexión.}
		\label{fig:ttgo_tdisplay_pines}
	\end{figure}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{ESP32 DevKitC / NodeMCU / LOLIN32}: mismo ESP32 de bajo coste pero no cuenta con pantalla, botones ni gestión de batería (coste aproximado: 5–8\,\texteuro{}) \cite{ESP32DevKitC2018}.
		\item \textbf{Arduino Nano 33 IoT / UNO Wi-Fi Rev2}: ARM Cortex-M0/M4 con Wi-Fi/BLE integrados, pero sin pantalla y más caro (coste aproximado: 30 \texteuro{}) \cite{ArduinoNano33IoT2019}.
		\item \textbf{M5Stack Core2}: basado en ESP32, incluye pantalla touchscreen de 2 pulgadas (320×240 px), y las funcionalidades pero por un mayor coste. (coste aproximado: 50\,\texteuro{}) \cite{M5StackCore22020}.
	\end{itemize}
	
	
	\subsection{Acelerómetros y detección de caídas}
	
	Para la detección de caídas en el prototipo se ha seleccionado el IMU \textbf{MPU-6050} (ver figura \ref{fig:mpu}), un dispositivo de bajo coste (aproximadamente 1\,\texteuro{}) de 6 ejes que combina acelerómetro y giroscopio con conversión A/D de 16 bit y un DMP (Digital Motion Processor) integrado. 	
	
	\noindent\textbf{Este módulo permite \cite{MPU6050Datasheet}:}
	\begin{itemize}
		\item \textbf{Medición de aceleración:} ±2/4/8/16 g, suficiente para capturar picos de impacto y cambios bruscos de movimiento en caídas .
		\item \textbf{Medición de rotación:} ±250/500/1000/2000 °/s, útil para caracterizar la orientación y la fase de giro durante una caída.
		\item \textbf{DMP integrado:} fusión inicial de acelerómetro y giroscopio en hardware, que descarga parte del procesamiento de la MCU y permite ejecutar algoritmos de detección en tiempo real con menor latencia.
		\item \textbf{Interfaz I\textsuperscript{2}C:} funciona a hasta 400 kHz, simplificando el cableado y compartiendo bus con otros sensores (p. ej. MAX30102).
	\end{itemize}
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{images/MPU6050.png}
		\caption[Diagrama de pines del MPU6050]{Diagrama del  \mbox{MPU6050)} con todos sus pines de conexión.}
		\label{fig:mpu}
	\end{figure}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{ADXL345}: acelerómetro de 3 ejes, ±2/4/8/16 g, A/D de 13 bit, interfaz I\textsuperscript{2}C/SPI; buena precisión estática pero requiere un giroscopio externo para fusión completa su coste es similar al MPU6050\cite{ADXL345Datasheet}.
		\item \textbf{BNO055}: IMUs de 9 ejes con magnetómetro o fusión completa en chip; ofrece mayor certeza en orientación espacial, pero a un coste superior (coste aproximado 10 \texteuro{}) \cite{BNO055Datasheet}.
	\end{itemize}

	\subsection{Sensor de pulso y oxímetro}
	
	Para la medición de frecuencia cardíaca y saturación de oxígeno (SpO$_2$) se ha seleccionado el módulo \textbf{GY-MAX30102} (ver figura \ref{fig:max}), que integra el sensor óptico MAX30102 con las siguientes características \cite{MAX30102Datasheet}:
	\begin{itemize}
		\item \textbf{Longitudes de onda:} LED rojo a 660 nm e infrarrojo a 880 nm, adecuadas para la discriminación hemoglobínica.
		\item \textbf{Conversión A/D:} resolución de 18 bit, que permite un amplio rango dinámico de señal.
		\item \textbf{Interfaz I\textsuperscript{2}C:} bus estándar a 400 kHz para comunicación con la MCU.
		\item \textbf{Dimensiones y consumo:} encapsulado compacto (5×3 mm) y consumo de operación típico en torno a 600 µA por LED.
	\end{itemize}
	
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{images/MAX30102.png}
		\caption[Diagrama de pines del MAX30102]{Diagrama del  \mbox{MAX30102)} con todos sus pines de conexión.}
		\label{fig:max}
	\end{figure}
	
	
	\noindent\textbf{Ventajas:}
	\begin{itemize}
		\item Muy económico (coste aproximado 1 a 2 \texteuro{}).
		\item Diseño modular que facilita su sustitución futura por sensores de mayor precisión.
	\end{itemize}
	
	\noindent\textbf{Limitaciones:}
	\begin{itemize}
		\item No homologado para uso clínico; su precisión es inferior a la de equipos médicos profesionales.  
		\item Algunas placas genéricas presentan fallas de diseño, lo que impide su funcionamiento \cite{LuisLlamas2021}.
	\end{itemize}
	
	\noindent\textbf{Alternativas consideradas:}
	\begin{itemize}
		\item \textbf{MAX30100}: predecesor con A/D de 16 bit y menor resolución, fue probado y termino siendo descartado. \cite{MAX30100Datasheet}.
		\item \textbf{MAX86150}: sensor combinado (ECG + PPG) con mayor precisión y funcionalidades integradas (coste aproximado 15 \texteuro{}) \cite{MAX86150Datasheet}.
		\item \textbf{TSL2561 + pulsioxímetro genérico}: uso de fotodetector independiente para PPG, que aumenta la complejidad de diseño y calibración (coste aproximado 12\texteuro{}).
	\end{itemize}
		
	

\section{Diseño de la pulsera (Hardware)}
	
	El objetivo es presentar una solución sencilla y modular que sirva como base. Aún usando sensores de bajo coste, se mantienen buenas prácticas de ingeniería: arquitectura en bus I\textsuperscript{2}C, y disposición clara de pines, de manera que el prototipo pueda evolucionar hacia un producto más robusto en caso de ser necesario y tener el presupuesto para comprar sensores de calidad.
	
	\subsection{Esquemáticos y PCB}
	
	A continuación se muestra la tabla de conexiones entre el ESP32 y los sensores MAX30102 y MPU-6050. Solo se emplean las líneas estrictamente necesarias, dejando libres pines adicionales que no son requeridos para este proyecto.

	\begin{table}[ht]
		\centering
		\caption{Conexión del sensor de pulso GY-MAX30102}
		\label{tab:conexion_max30102}
		\begin{tabular}{|p{4cm}|p{3cm}|p{5cm}|}
			\hline
			\textbf{Pin del MAX30102} & \textbf{Pin del ESP32}      & \textbf{Uso}                    \\ \hline
			VIN                        & 3.3\,V                       & Alimentación                          \\ \hline
			GND                        & GND                          & Tierra                                   \\ \hline
			SCL                        & GPIO 22 (SCL)                & I\textsuperscript{2}C reloj            \\ \hline
			SDA                        & GPIO 21 (SDA)                & I\textsuperscript{2}C datos            \\ \hline
			INT                        & —                            & No utilizado en este prototipo        \\ \hline
		\end{tabular}
	\end{table}
	
		
	
	Para simplificar el cableado y aprovechar el bus I\textsuperscript{2}C, ambos sensores comparten las mismas líneas de reloj (SCL) y datos (SDA) en el ESP32. En particular, GPIO 22 (SCL) y GPIO 21 (SDA) pueden conectarse en paralelo a múltiples dispositivos I\textsuperscript{2}C sin interferencias, ya que el protocolo gestiona direcciones únicas para cada sensor, por lo cual no es ningún problema reutilizar estos pines.
	
	
	\begin{table}[ht]
		\centering
		\caption{Conexión del IMU MPU-6050}
		\label{tab:conexion_mpu6050}
		\begin{tabular}{|p{3.5cm}|p{3cm}|p{5cm}|}
			\hline
			\textbf{Pin del MPU-6050} & \textbf{Pin del ESP32}      & \textbf{Uso}                            \\ \hline
			VCC                        & 3.3\,V                       & Alimentación                                  \\ \hline
			GND                        & GND                          & Tierra                                           \\ \hline
			SCL                        & GPIO 22 (SCL)                & I\textsuperscript{2}C reloj                    \\ \hline
			SDA                        & GPIO 21 (SDA)                & I\textsuperscript{2}C datos                    \\ \hline
			XDA                        & —                            & No necesario (uso I\textsuperscript{2}C)        \\ \hline
			XCL                        & —                            & No necesario (uso I\textsuperscript{2}C)        \\ \hline
			ADO                        & —                            & Dirección I\textsuperscript{2}C fija (0x68)     \\ \hline
			INT                        & —                            & No utilizado en este prototipo                \\ \hline
		\end{tabular}
	\end{table}
	
	
	En la figura \ref{fig:esquema_prototipo}, se puede observar un esquemático realizado en Fritzing, mostrando todas las conexiones que se esperan hacer para permitir el funcionamiento del microcontrolador y sensores.
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{images/esquema_prototipo.jpg}
		\caption[Esquemático del prototipo]{Esquemático de conexión entre el ESP32 y los sensores MAX30102 y MPU-6050.}
		\label{fig:esquema_prototipo}
	\end{figure}
	
	
	\subsection{Desarrollo de software del prototipo}
	
	Ya conociendo los componentes elegidos para este proyecto se puede describir el código usado en arduino. El código fuente del prototipo está disponible como material complementario en la carpeta \texttt{CODE} de este repositorio:  
	\url{https://github.com/Diegodepab/TFG_Pulsera_Seguimiento_Pacientes_Avanzada_Edad/tree/main/CODE}
	
	Uno de los principales objetivos del prototipo es explorar una variedad amplia de funciones probando su viabilidad, además de tener un enfoque basado en componentes donde sin importar el tamaño del código se busca minimizar la cohesión diseñando módulos de tal manera que tengan menos dependencias internas entre sí, favoreciendo un futuro donde sustituciones o problemas en un sensor no afecten el funcionamiento global de la pulsera.
	
	El prototipo se divide en las siguientes funcionalidades:
	
		\subsubsection{Uso del sensor GY‑MAX30102}
	Para gestionar el sensor GY‑MAX30102 se utiliza la librería \texttt{MAX30105.h}, que simplifica la configuración y lectura del señales. En el código, se realiza:
	
	\begin{enumerate}
		\item \textbf{Inicialización:} Se comprueba el funcionamiento y conexión del sensor, además se ajusta brillo, modo y frecuencia de muestreo.
		\item \textbf{Lectura:} El sensor verifica constantemente si puede realizar un análisis sin detener el flujo principal.
		\item \textbf{Extracción de muestras:} El MAX30102, equipado con LEDs rojo e infrarrojo, al colocarse en la piel (dedo o muñeca) mide la luz reflejada para calcular la saturación captando el distinto comportamiento que la sangre tiene ante la luz.
		\item \textbf{Evaluación de muestras:} Se usa la librería para traducir las señales a ritmo cardíaco y saturación de oxígeno, además de descartar las lecturas inválidas.
		\item \textbf{Procesado:} las lecturas válidas se copian en buffers y se hace una media para calcular frecuencia cardíaca y SpO\textsubscript{2} más acertados posibles.
		\item \textbf{Salida:} Se actualiza la pantalla con los valores procesados, y opcionalmente se envían.
	\end{enumerate}
	
	\subsubsection{Uso del sensor MPU‑6050}
	Se emplea la librería \texttt{MPU6050\_light.h} para obtener aceleraciones y aplicar ajustes de calibración, ofreciendo dos funciones:
	
	\begin{enumerate}
		\item \textbf{Detección de caída:}
		\begin{enumerate}
			\item Se toma consideración la magnitud máxima del vector de aceleración junto a un umbral que se recomendaría modificar por usuario, además se da importancia a cambios bruscos en dos ejes.
			\item Si se supera, se muestra alerta y se envía el evento por MQTT.
		\end{enumerate}
		\item \textbf{Podómetro:}
		\begin{enumerate}
			\item Se aplica un filtro de media móvil (ventana fija) sobre la señal Z.
			\item Se detecta un paso cuando la señal filtrada supera el umbral y ha pasado el intervalo mínimo entre pasos.
			\item Se incrementa el contador de pasos y se actualiza la pantalla.
		\end{enumerate}
	\end{enumerate}
	

	\subsubsection{Medición de tiempo}
	Para gestionar la fecha y hora de la pulsera se emplea la librería \texttt{<time.h>}, que facilita la sincronización NTP (De sus siglas en inglés Network Time Protocol, protocolo que mantiene los relojes de los sistemas informáticos alineados con gran precisión).
	
	La inicialización y uso se estructura en tres funciones clave:
	\begin{enumerate}
		\item En caso de tener conexión Wi-Fi obtiene la hora de España y sincroniza, en caso contrario usa la hora cargada.
		\item Se muestra la hora y minuto en la parte superior de la pantalla.
		\item Se guarda un registro de los datos con la hora antes de ser enviados, para tener un mayor control de las mediciones y ver la evolución temporal de los datos.
	\end{enumerate}
	
	\subsubsection{Conexión Wi‑Fi}
	Se emplea la librería \texttt{WiFi.h} para conectar la pulsera a la red:
	
	\begin{enumerate}
		\item \textbf{Inicio de conexión:}
		\begin{enumerate}
			\item En el código se da el SSID (Service Set Identifier) que es el nombre público de la red Wi‑Fi y la contraseña para entablar conexión.
			\item Si conecta, se muestra la dirección IP en el monitor serie y continua con demás funciones que ameritan internet.
		\end{enumerate}
		\item \textbf{Gestión de fallo:}
		\begin{enumerate}
			\item Si no conecta en el tiempo límite, se muestra un mensaje de error en pantalla. El dispositivo intentará reconectar de forma periódica y también lo hará cada vez que haya un nuevo dato que deba enviarse (en el prototipo los valores se envían cada minuto o ante una situación de alarma; esta cadencia puede modificarse). Mientras no exista conectividad, las muestras se almacenan temporalmente en el buffer circular configurado del dispositivo y, al recuperarse la conexión, los datos pendientes se reenvían al broker. Si el buffer alcanza su capacidad, se aplica la política de desbordamiento descrita en la sección «Almacenamiento de datos sin conexión».
	
		\end{enumerate}
	\end{enumerate}
	
	\subsubsection{Conectividad MQTT y envío de datos}
	Se utiliza la librería \texttt{PubSubClient.h} sobre TCP/IP para publicar eventos y métricas:
	
	\begin{enumerate}
	\item \textbf{Inicialización y conexión:} Intenta acceder al broker y puerto indicados, intentando suscribirse como cliente, en caso de no darse una conexión se reintentará en un minuto o cuando tenga la necesidad de mandar una alarma. 
	\item \textbf{Publicación de mensajes:} Al tener información que enviar crea un JSON con marca de tiempo, tipo de evento y los datos que contiene, en un formato claro para fácilitar su envío a una base de datos.
	\end{enumerate}
	

	\subsubsection{Almacenamiento de datos sin conexión}
	Se implementó un buffer circular de tamaño configurable para conservar temporalmente las lecturas cuando la pulsera no puede enviarlas por falta de conectividad. Su funcionamiento principal es:
	
	\begin{enumerate}
		\item \textbf{Inserción:}
		\begin{enumerate}
			\item Si no es posible enviar una métrica (Wi-Fi o MQTT no disponibles), la muestra se guarda en la caché con marca temporal, pasos y valores medios de \texttt{bpm} y \texttt{SpO\textsubscript{2}}.
		\end{enumerate}
		
		\item \textbf{Gestión de desbordamiento:}
		\begin{enumerate}
			\item Cuando la caché alcanza su capacidad, se reduce la ocupación combinando pares de muestras en una sola entrada: los pasos y marcas de tiempo se mantienen del segundo y los valores de \texttt{bpm} y \texttt{SpO\textsubscript{2}} se promedian.
		\end{enumerate}
		
		\item \textbf{Reenvío:}
		\begin{enumerate}
			\item Al recuperarse la conectividad se calcula un resumen agregado (intervalo temporal, pasos totales, \texttt{avg\_bpm}, \texttt{avg\_SpO\textsubscript{2}} y número de muestras) y se publica como un único mensaje al broker.
		\end{enumerate}
	\end{enumerate}
	
	
	\subsubsection{Fondos animados y botones de la pantalla}
	Para gestionar la pantalla y los botones integrados del TTGO T-Display se usa la librería \texttt{TFT\_eSPI}, la cual está optimizada y permite enviar directamente mapas de bits desde \texttt{PROGMEM} sin consumir RAM, abstrae la inicialización de pines y velocidad de bus.
	
	La función \texttt{handleButtonsAndAnimation()} unifica dos tareas clave:
	\begin{enumerate}
		\item \textbf{Gestión de botones de emergencia:}
		\begin{enumerate}
			\item Los botones integrados se encuentran en los pines \texttt{GPIO0} y \texttt{GPIO35}. 
			\item Pulsación simultánea de ambos botones por más de 2 segundos muestra en pantalla  que se ha presionado ambos botones y realiza una publicación MQTT de alerta.  
			\item Al pasar 2 segundos la pulsera vuelve a la normalidad.
		\end{enumerate}
		\item \textbf{Animación de fondo}, esta función fue simplificada en el prototipo final para favorecer el uso de memoria en la cache usando solo un frame estático, pero se usa en el ejemplo de pulsera sin conexión Wi-Fi.  
		\begin{enumerate}
			\item Se incluyen diez frames estáticos (\texttt{frame\_000.h}…\texttt{frame\_009.h}) generados previamente con un script Python que convierte GIFs en arrays de 16‑bit.  
			\item Dichos frames serán cambiados cada 100 ms dando una apariencia de movimiento real.
		\end{enumerate}
	\end{enumerate}
	
	\subsection{Protocolos de comunicación}
	
	Para la transmisión de las métricas y alertas del prototipo se eligió el protocolo MQTT (Message Queuing Telemetry Transport). MQTT es un protocolo de mensajería ligero basado en el patrón publicación/suscripción mediante la figura central de un \emph{broker}, lo que permite desacoplar emisores y receptores en tiempo y en espacio. Esta topología resulta especialmente ventajosa en sistemas embebidos de recursos limitados, como el ESP32, porque reduce la complejidad del firmware (el nodo solo publica y/o se suscribe a \emph{topics}) y simplifica la escalabilidad del sistema al centralizar el enrutado de mensajes en el broker \cite{mosquitto,aws_mqtt}.
	
	Las razones principales para elegir MQTT en este proyecto son su ligereza y su eficiencia: el protocolo tiene una sobrecarga de control reducido y mecanismos integrados (por ejemplo, niveles de QoS) que permiten ajustar la fiabilidad de entrega según la criticidad del dato (QoS 0/1/2), optimizando así el uso de ancho de banda y el consumo energético del dispositivo. Además, MQTT soporta sesiones persistentes y reconexiones automáticas que facilitan la recuperación tras pérdidas temporales de cobertura —característica útil en dispositivos móviles o con redes inestables— y permite almacenar mensajes en el broker hasta que los clientes vuelvan a estar disponibles \cite{seoane2021,aws_mqtt}.
	
	Estas características ofrecen un equilibrio adecuado entre coste, consumo y fiabilidad: el dispositivo puede enviar pequeñas cargas con periodicidad reducida (por ejemplo, mediciones cada minuto) y confiar en el broker para la distribución y el reenvío en caso de desconexiones, mientras que la plataforma central puede suscribirse a los topics relevantes para procesar alarmas y registros históricos. Por todo ello, MQTT constituye una solución ampliamente utilizada y bien soportada. \cite{mosquitto,hernandez2024}.

	
	\subsection{Ejemplo en funcionamiento}
	
	
	El prototipo desarrollado tiene carácter demostrativo: su diseño prioriza la facilidad de montaje y se han elegido componentes económicos que, como se mencionó anteriormente, no llegan a dar la fiabilidad para un tema tan importante como es el monitoreo de pacientes o personas de avanzada edad. Por ello, los componentes escogidos (ESP32, sensor de pulso/SpO\textsubscript{2} MAX30102 y acelerómetro/giroscopio MPU-6050) permiten validar conceptos y flujos de datos, pero no garantizan la precisión necesaria para monitorizar pacientes o personas de edad avanzada en entornos clínicos reales.
	
	La Figura \ref{fig:prototipo} muestra el montaje final en protoboard, correspondiente al esquemático realizado en Fritzing. En este prototipo se puede alimentar con una conexión tipo C como se muestra en la figura tanto de una batería portable o cualquier fuente de poder. También se podría recomendar la conexión  de una batería LiPo (polímero de litio) que es una batería recargable que utiliza un electrolito en forma de polímero en lugar de un líquido cumpliendo  una tensión de 3.3V para su funcionamiento. No es necesario tener conectado algún cable de comunicación externo al prototipo.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.4\textwidth]{images/prototipo.jpg}
		\caption[Prototipo]{Prototipo mostrando la conexión entre el ESP32 y los sensores MAX30102 y MPU-6050 en protoboard.}
		\label{fig:prototipo}
	\end{figure}

	La pulsera, al ser conectada a una fuente de poder, comprobará que los sensores estén funcionando correctamente. Una vez confirmado que la conexión es correcta, procederá a evaluar la conexión Wi-Fi y el broker MQTT; en caso de que alguno de estos falle, saldrá un aviso como el de la figura \ref{fig:error}, y la pulsera guardará los datos hasta que se logre hacer la conexión.
		
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.4\textwidth]{images/error_wifi.jpg}
		\caption[Ejemplo]{Ejemplo de mensaje de error de conexión al no encontrar el Wi-Fi.}
		\label{fig:error}
	\end{figure}
	
	
	La pulsera constantemente irá registrando los valores del MPU6050 para que, en caso de movimientos, determine si son pasos, los cuales aumentarán el contador de pasos en la pantalla. Finalmente, se usó el sistema de detección de caídas basado en acelerómetro que evalúa la magnitud máxima del vector de aceleración, es decir, un movimiento muy rápido de manera abrupta. Como se mencionó, esto es basado en un umbral que idealmente sería modificado para ajustarse al estilo de vida de la persona, evitando falsos positivos por movimientos cotidianos. En caso de detectar una caída, se mostrará la pantalla de alarma roja indicando que se detectó una caída y se enviará una notificación de alarma junto a los ejes para determinar qué tan brusco fue el movimiento.
	
	En el caso de la monitorización cardíaca, funciona distinto: el uso de la librería permite la detección de piel cercana al sensor; en caso de no detectar directamente, no realiza ningún análisis. En el protoboard, se recomienda usar un dedo para mostrar cómo se muestra en la figura \ref{fig:sangre}; no obstante, también puede usarse la muñeca u otras partes del cuerpo para realizar un análisis. Mientras se realiza, hay un umbral que descarta los valores anómalos causados por la baja calidad del sensor, y va promediando los valores con sentido que se van detectando en un segundo, llegando a obtenerse una leída de datos por segundo que modificará el valor visto en la pantalla. Por practicidad, lo que se hace actualmente es una lectura por cada minuto; será enviada por protocolo MQTT, aprovechando y enviando el tiempo, los pasos acumulados, el BMP y SpO\textsubscript{2}.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.35\textwidth]{images/analizando.jpg}
		\caption[Ejemplo]{Ejemplo de análisis de ritmo cardíaco y oxigenación en sangre.}
		\label{fig:sangre}
	\end{figure}
	
	El resto de funciones siguen la lógica explicadas en el desarrollo de software, pudiendo indagarse más en el Apéndice A1, sobre el manual de usuario en el uso del prototipo además de la existencia de un video que muestra todas las funcionalidades 	\url{https://www.youtube.com/watch?v=y1xrh9f9NOg}.
	


\section{Creación de la base de datos}


La base de datos se ejecuta una instancia de PostgreSQL versión 13.3 como base de datos principal del proyectoo. Toda la lógica de manejo, migración y acceso a la base de datos se realiza con código Python en el backend.



\subsection{Uso de PostgreSQL}

Para la persistencia de los datos del proyecto se optó por PostgreSQL (versión 13.x en la configuración del servicio). PostgreSQL es un sistema gestor de bases de datos relacional, libre y maduro, con soporte ACID, amplia adopción industrial y capacidades avanzadas (tipos JSONB, índices, extensiones, etc.). Estas características lo hacen especialmente adecuado cuando se buscan garantías de integridad y escalabilidad sin coste de licenciamiento, facilitando además la trazabilidad y auditoría de datos en aplicaciones de telemonitorización. \cite{postgresql_doc,postgresql_13}

En el contexto de un proyecto con dispositivos ESP32 que envían telemetría, PostgreSQL aporta un almacén robusto para series temporales, eventos y registros agregados, permitiendo consultas relacionales complejas para análisis y generación de informes, facilitando el seguimiento de datos en caso de algún error.

\subsection{Implementación y despliegue con contenedores}

Para facilitar el despliegue reproducible y el desarrollo, se emplea PostgreSQL en un contenedor (Docker). La contenedorización permite materializar una instancia de base de datos preconfigurada con las siguientes consideraciones operativas:

\begin{itemize}
	\item \textbf{Variables de entorno:} la creación inicial del usuario, la contraseña y la base de datos se define mediante variables de entorno estándar \texttt{POSTGRES\_PASSWORD}, (\texttt{POSTGRES\_USER}, \texttt{POSTGRES\_DB}), lo que permite parametrizar entornos (desarrollo, pruebas, producción) sin modificar la imagen base. \cite{docker_postgres}
	\item \textbf{Persistencia:} los datos se mantienen en un volumen dedicadopara evitar pérdida de información al reiniciar o recrear contenedores; además se puede montar un directorio con scripts de inicialización que se ejecutan la primera vez que se crea la base. \cite{docker_persist,docker_postgres}
	\item \textbf{Acceso por red y puertos:} el contenedor expone el puerto interno 5432, que puede mapearse a un puerto del host (por ejemplo 15432) para permitir conexiones externas desde entornos de desarrollo o herramientas de administración.
	\item \textbf{Logs y gestión:} la gestión de logs se realiza mediante las opciones de logging de Docker y políticas de rotación, limitando tamaño y número de archivos para facilitar la depuración y evitar consumos indeseados de disco. La orquestación con Docker Compose aporta reproducibilidad y automatización en el ciclo de vida de la base de datos. \cite{docker_persist}
\end{itemize}

Estas prácticas facilitan levantar y administrar la base de datos de forma automática y reproducible, permiten ejecutar scripts de inicialización y garantizan portabilidad entre distintos entornos.

\subsection{Integración con Python y control de esquema}

La aplicación Python se conecta a PostgreSQL mediante drivers y bibliotecas especializadas. Se psycopg2 como adaptador DB-API para PostgreSQL; sobre estos drivers se emplean otras librerías como SQLAlchemy que sirve de capa de abstracción/ORM para modelar entidades y consultas en Python. \cite{psycopg2_doc,sqlalchemy_doc}

Para el control y evolución del esquema (migraciones) el proyecto utiliza Alembic, la herramienta de migraciones asociada a SQLAlchemy. Alembic permite versionar cambios en la estructura de la base de datos (creación de tablas, alteración de columnas, índices, etc.) mediante scripts de migración reproducibles, lo que facilita desplegar actualizaciones del esquema en distintos entornos y mantener sincronizada la base con el código de la aplicación. \cite{alembic_doc}



\subsection{Modelo entidad-relación}

Antes de la implementación física se define un diagrama entidad-relación (ER) que refleje las entidades principales y su importancia en la aplicación, en la figura \ref{fig:db} se puede ver las principales tablas con las que se trabajará en este proyecto.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{images/db_bracelet.png}
	\caption[Modelo entidad-relación]{Modelo entidad-relación.}
	\label{fig:db}
\end{figure}

\subsubsection{Generalidades: trazabilidad y metadatos temporales}

Todas las tablas del esquema incluyen dos columnas de auditoría temporal: \texttt{create\_ts} y \texttt{update\_ts}.  

\begin{itemize}
	\item \texttt{create\_ts} (TIMESTAMP): indica la fecha y hora en que la fila fue creada. 
	\item \texttt{update\_ts} (TIMESTAMP): refleja la última modificación de la fila. En el esquema se implementa mediante un trigger que actualiza \texttt{update\_ts = now()} antes de cada \texttt{UPDATE}, lo que permite auditar cambios y detectar discrepancias en registros clínicos o administrativos.
\end{itemize}

Dado que el trabajo está relacionado con la salud, mantener estas marcas temporales y registros inmutables es una práctica esencial para reconstruir la secuencia de eventos y cumplir requisitos de trazabilidad en aplicaciones sanitarias.

\subsubsection{Explicación de cada tabla}
A continuación, se describen las tablas principales del modelo de datos.  
Cada entrada incluye los campos relevantes y una breve justificación de su importancia en el sistema.



\texttt{1) user\_account}


 Centraliza la autenticación, la gestión de usuarios (cuidadores, administradores, pacientes) y permite auditar acciones por cuenta, es la tabla más importante de la plataforma.


\begin{itemize}
	\item \texttt{id} (INTEGER, PK, autoincrement). Ejemplo: \texttt{1}. Identificador único de la cuenta.
	\item \texttt{email} (VARCHAR(255), UNIQUE). Ejemplo: \texttt{admin@bracelet.io}. Sirve para autenticar y contactar al usuario.
	\item \texttt{password} (VARCHAR(255)). Ejemplo: \texttt{\textless hashed password\textgreater}. Almacena el hash de la contraseña (nunca en texto claro).
	\item \texttt{user\_role\_name} (VARCHAR(64), FK \texttt{user\_role.name}). Ejemplo: \texttt{admin}. Cuenta con su propia tabla y vincula los permisos asociados, Admin permisos completos, user es el caso de Doctores, cuidadores o personal encargado con mucha responsabilidad y paciente que correspondería a datos personales y acceso al chat con su doctor.
	\item \texttt{user\_status\_name} (VARCHAR(64), FK \texttt{user\_status.name}). Ejemplo: \texttt{active}. Indica visibilidad / estado de la cuenta, al crear una cuenta debe ser revisada por un admin para activarla.
	\item \texttt{first\_name}, \texttt{last\_name} (VARCHAR). Ejemplo: \texttt{Diego}, \texttt{De Pablo}. Datos identificativos.
	\item \texttt{phone} (VARCHAR(64)). Ejemplo: \texttt{+177 555-555-555}. información para hacer realista la plataforma.
	\item \texttt{approval\_toc\_ts} (TIMESTAMP). Fecha en que aceptó Términos y Condiciones.
	\item \texttt{blocked\_ts} (TIMESTAMP). Marca si la cuenta fue bloqueada desde determinada fecha, con un número elevado de intentos fallidos de inicio de sección se bloquea la cuenta por seguridad.
\end{itemize}


\texttt{2) user\_role}

Define conjuntos de permisos y separa responsabilidades (quién puede ver/editar datos clínicos, quién solo visualiza).

\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{admin}, \texttt{user} o \texttt{patient}.
\end{itemize}


\texttt{3) user\_status}

Permite otra capa de seguridad al controlar la confirmación al crear una cuenta o el bloquear cuentas con actividad sospechosa.

\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{active}, \texttt{pending}, \texttt{blocked}.
\end{itemize}


\texttt{4) permission\_grant}

Catálogo para asignar niveles de acceso granular sobre las entidades del sistema, el administrador tendrá todos los permisos siempre y ya dependiendo de las actividades las cuentas no tendrán permisos o solo de lectura.


\begin{itemize}
	\item \texttt{name} (VARCHAR, PK). Ejemplo: \texttt{none}, \texttt{read}, \texttt{write}.
\end{itemize}

\texttt{5) entity}

Lista de objetos del dominio sobre los que se aplican permisos (permite gestionar ACL por entidad, evitando errores de tipos y manteniendo buenas prácticas).

\begin{itemize}
	\item \texttt{name} (VARCHAR, PK). Ejemplo: \texttt{patient}, \texttt{study}.
\end{itemize}



\texttt{6) permission}

Centraliza la política de acceso; facilita comprobar permisos desde el frontend.
\begin{itemize}
	\item \texttt{user\_role\_name} (PK componente, FK a \texttt{user\_role}).
	\item \texttt{entity\_name} (PK componente, FK a \texttt{entity}).
	\item \texttt{read}, \texttt{write}, \texttt{delete} (VARCHAR referenciando \texttt{permission\_grant.name}). Ejemplo: \texttt{read='read'}.
	\item \texttt{ui\_visibility} (BOOLEAN, default TRUE). Controla si la entidad aparece en la interfaz para ese rol.
\end{itemize}





\texttt{7) pathology}

Catálogo de patologías clínicas para relacionar al paciente con su historial, también servirá de base de datos de las enfermedades que se manejan en el centro de salud.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{name} (VARCHAR(255)). Ejemplo: \texttt{Diabetes}.
\end{itemize}


\texttt{8) patient}


Nodo central del dominio clínico; relaciona telemetría, alarmas y patologías con la identidad del paciente.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{code} (VARCHAR(255), UNIQUE). Por razones de seguridad se recomendaría guardar un código identificativo para priorizar el anonimato del paciente, pero para mayor entendimiento se trabajo como si fuera nombre y apellido, ejemplo: \texttt{Diego De Pablo}
	\item \texttt{gender} (VARCHAR(64), FK a \texttt{gender\_type.name}). Ejemplo: \texttt{male}.
	\item \texttt{weight} (INTEGER). Ejemplo: \texttt{70} (kg).
	\item \texttt{birth\_date} (DATE). Ejemplo: \texttt{1990-01-01}.
	\item \texttt{owner\_user\_id} (FK a \texttt{user\_account.id}). Ejemplo: \texttt{1} (cuenta del usuario que cuida del paciente).
	\item \texttt{patient\_user\_id} (FK nullable a \texttt{user\_account.id}). Ejemplo: \texttt{15} (si el paciente tiene cuenta propia).
\end{itemize}



\texttt{9) patient\_pathology}

Relación N:M que registra cuándo se detectó una patología en un paciente (historial clínico).
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK a \texttt{patient.id}), \texttt{pathology\_id} (FK a \texttt{pathology.id}).
	\item \texttt{detection\_date} (DATE). Ejemplo: \texttt{2024-03-14}.
\end{itemize}


\texttt{10) gender\_type}

Catálogo de tipos de género para integridad referencial y estandarización de datos.
\begin{itemize}
	\item \texttt{name} (VARCHAR(64), PK). Ejemplo: \texttt{male}, \texttt{female}, \texttt{other}.
\end{itemize}


\texttt{11) study}

Almacena la telemetría recibida de la pulsera; sirve para análisis temporal, detección de tendencias y generación de informes clínicos.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK a \texttt{patient.id}).
	\item \texttt{step\_count} (INTEGER). Ejemplo: \texttt{1000}. Contador acumulado de pasos.
	\item \texttt{bpm} (INTEGER). Ejemplo: \texttt{75} (latidos por minuto).
	\item \texttt{spo2} (INTEGER, nullable). Ejemplo: \texttt{98} (\%). Nullable porque a veces no hay lectura válida.
	\item \texttt{ts} (TIMESTAMP / timestamptz). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
\end{itemize}

\texttt{12) alarm}

 Registro de eventos críticos que requieren respuesta inmediata o análisis posterior; permite priorizar intervenciones según \texttt{is\_urgent}
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{patient\_id} (FK).
	\item \texttt{alarm\_type} (VARCHAR(64)). Ejemplo: \texttt{fall\_detected}, \texttt{button\_alarm}.
	\item \texttt{ts} (TIMESTAMP). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
	\item \texttt{is\_urgent} (BOOLEAN, default FALSE). Ejemplo: \texttt{True}.
\end{itemize}


\texttt{15) chat}
Soporte de mensajería entre usuarios (familiares, cuidadores, personal sanitario, personal de servicio de la aplicación). \\
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{user1\_id}, \texttt{user2\_id} (FKs a \texttt{user\_account.id}).
	\item \texttt{administration} (BOOLEAN). Ejemplo: \texttt{False}. Indica chat de soporte/administración si \texttt{True}.
\end{itemize}


\texttt{16) message}
Forma sencilla de almacenar la conversación.
\begin{itemize}
	\item \texttt{id} (INTEGER, PK), \texttt{chat\_id} (FK a \texttt{chat.id}), \texttt{sender\_id} (FK a \texttt{user\_account.id}, \texttt{ON DELETE SET NULL}).
	\item \texttt{content} (TEXT, max\_length \textasciitilde 1000). Ejemplo: \texttt{"Hello, how are you?"}.
	\item \texttt{ts} (TIMESTAMP). Ejemplo: \texttt{2025-05-26T12:34:56Z}.
\end{itemize}


Cada tabla será usada en la plataforma para herramientas que faciliten la telemedicina además de centrarse en utilidad cotidiana del manejo de pacientes.



\subsection{Herramientas de administración}

Para la administración visual y la inspección del esquema se emplea \textbf{DBeaver}, un cliente gráfico multiplataforma que permite explorar tablas, ejecutar consultas SQL y gestionar conexiones. En el apéndice A.4.1 se muestra como manipular DBeaver; su uso acelera las tareas de depuración y validación durante el desarrollo. Como alternativa se dispone de \texttt{pgAdmin}. \cite{dbeaver_doc,postgresql_doc}


\subsection{Población de base de datos}

En el proyecto se implementa el archivo seed.py; es un script que se utiliza para poblar la base de datos con datos de ejemplo y configuración inicial. Permite tener la base de datos lista para usar, sin necesidad de crear manualmente cada usuario o dato, facilitando el desarrollo y la presentación del proyecto con datos falsos pero que parecen realistas para su demostración. También se puede hacer uso uso de las variables para guardar datos de pacientes reales en caso de que se quiera desarrollar una demostración con pacientes reales; pero buscando evitar los conflictos que lleva trabajar con datos reales, en este proyecto se queda con la demostración de cómo sería con datos ficticios.



\section{Desarrollo de la plataforma web}


Una plataforma web de telemedicina tiene cada vez mayor relevancia por su capacidad de facilitar el acceso a servicios sanitarios, mejorar el seguimiento remoto de pacientes y optimizar los flujos de trabajo clínicos. Los conocimientos de un ingeniero de la salud (o bioinformático con experiencia en sistemas clínicos) son valiosos porque permiten traducir requisitos clínicos en especificaciones técnicas: identificar necesidades de confidencialidad, latencia y trazabilidad; priorizar la usabilidad para personal sanitario; y diseñar soluciones que integren seguridad, interoperabilidad y validación clínica. Esta visión interdisciplinaria contribuye a que la plataforma sea eficiente, segura y realmente útil para el equipo médico y para los pacientes.


\subsection{Arquitectura general}

El sistema sigue una arquitectura cliente--servidor basada en microservicios, donde cada componente principal se ejecuta en un contenedor independiente gestionado por Docker. Dicha aproximación facilita la escalabilidad, el mantenimiento, la replicabilidad del entorno y el despliegue tanto en desarrollo como en producción.

\subsubsection{Componentes principales}
\begin{description}
	\item[Frontend (cliente)] Interfaz web desarrollada con Svelte. Los usuarios acceden mediante navegador y el frontend realiza peticiones HTTP/HTTPS a la API para obtener o enviar datos.
	\item[Servidor de aplicación (Backend / API)] Contenedor \texttt{api} que ejecuta la lógica de negocio y expone una API REST (puerto \texttt{8001} en este proyecto). Gestiona autenticación, usuarios, dispositivos, estudios médicos y orquesta el acceso a la base de datos y a servicios auxiliares.
	\item[Base de datos (PostgreSQL)] Contenedor \texttt{db} donde se almacenan los datos. El backend se conecta mediante variables de entorno para credenciales y parámetros de conexión. Los datos persisten en volúmenes Docker.
	\item[Servidor de mensajería / caché (Redis)] Contenedor \texttt{redis} usado para caché, gestión de sesiones y colas de tareas (tareas en segundo plano, publish/subscribe para notificaciones).
	\item[Servidor web / proxy inverso (Nginx)] Contenedor \texttt{nginx} que actúa como punto de entrada HTTP/HTTPS: sirve archivos estáticos del frontend si procede y redirige peticiones al backend. 
\end{description}

\subsubsection{Redis}
Redis (REmote DIctionary Server) es un almacén de estructuras de datos en memoria diseñado para ofrecer acceso ultrarrápido a datos volátiles y semipersistentes. Se utiliza habitualmente como \emph{cache} delante de una base de datos relacional, como broker de mensajes (pub/sub y colas) y como motor de streams para procesamiento de eventos en tiempo real. \cite{redis_persistence}

En arquitecturas de microservicios, Redis aporta tres capacidades clave:
\begin{itemize}
	\item \textbf{Caché de lectura y sesión:} reduce la latencia y la carga sobre la base de datos principal almacenando resultados o sesiones en memoria con tiempos de expiración configurables.
	\item \textbf{Mensajería y colas:} mediante patrones pub/sub, listas y streams permite desacoplar productores y consumidores (por ejemplo, notificaciones, envío de correos o procesos asíncronos), con latencias muy bajas propias de un sistema en memoria. \cite{redis_pubsub,redis_streams}
	\item \textbf{Almacenamiento de estado temporal:} cuenta para rate-limiting, contadores, locks distribuidos o datos de sesión de videoconsulta en curso, que exigen alta velocidad de acceso.
\end{itemize}


\subsubsection{Nginx}
 Es un servidor web y proxy inverso orientado a alto rendimiento mediante un modelo de ejecución \emph{event-driven} y asincrónico. Sus usos comunes son servir contenido estático con alta eficiencia, actuar como proxy inverso / puerta de entrada a APIs y realizar balanceo de carga entre réplicas de microservicios. Al situarse como primer punto de entrada, Nginx centraliza funciones transversales como terminación TLS (Transport Layer Security) es el protocolo que cifra y protege la comunicación entre dos extremos (por ejemplo: navegador y servidor web), enrutado según rutas o subdominios, cache de respuesta, limitación de tasa y políticas de seguridad.\cite{nginx_reverseproxy,nginx_docs}


Ventajas que aporta en este proyecto:
\begin{itemize}
	\item Almacenar las claves privadas y certificados con permisos restringidos; montar los ficheros de certificado como volúmenes en Docker y automatizar renovación (por ejemplo con Certbot/Let's Encrypt) para evitar expiraciones manuales. \cite{certbot_doc}
	\item Ajustar parámetros de rendimiento y habilitar compresión/control de caché donde sea apropiado para reducir latencia y consumo de ancho de banda.
	\item Usar Nginx como primer filtro: exponer sólo puertos 80/443 externamente, y mantener backend y Redis en redes privadas sin exposición pública.
	\item Comprobar la configuración antes de recargar (\texttt{nginx -t}) y disponer de políticas de restart / healthchecks en Docker Compose para evitar caídas por recargas erróneas.
\end{itemize}

Nginx y Redis actúan de forma complementaria: mientras Nginx optimiza y protege la entrada de tráfico (cifrado, balanceo, caching de respuestas HTTP), Redis acelera el acceso a datos y desacopla procesos internos (cache, colas, streams). Juntos permiten una plataforma de telemedicina con menor latencia, mayor escalabilidad y un punto claro para aplicar políticas de seguridad y observabilidad. \cite{nginx_reverseproxy,nginx_loadbalancer,redis_pubsub}


\subsubsection{Flujo y puentes de comunicación}
\begin{itemize}
	\item \textbf{Frontend \(\rightarrow\) Backend:} Peticiones REST (HTTP/HTTPS) desde la aplicación cliente a la API; autenticación mediante tokens/headers.
	\item \textbf{Backend \(\rightarrow\) Base de datos:} Operaciones CRUD contra PostgreSQL mediante librerías Python (conexión configurable por variables de entorno).
	\item \textbf{Backend \(\rightarrow\) Redis:} Lectura/escritura de datos temporales, gestión de sesiones y encolado de tareas asíncronas.
	\item \textbf{Nginx \(\rightarrow\) Backend/Frontend:} Nginx recibe todo el tráfico externo y enruta según la URL/patrones configurados.
\end{itemize}



\subsubsection{Despliegue con Docker Compose}
El despliegue se orquesta mediante \texttt{docker-compose.yml}. Con un único comando se levantan los contenedores y se crean las redes y volúmenes necesarios, lo que aporta reproducibilidad entre máquinas:
\begin{itemize}
	\item Creación y persistencia de volúmenes para la base de datos.
	\item Variables de entorno centralizadas en un fichero \texttt{.env}.
	\item Dependencias entre servicios (por ejemplo, esperar a que PostgreSQL y Redis estén disponibles antes de iniciar el backend).
\end{itemize}

\subsubsection{Lanzamiento automatizado (launch.sh)}
Se incluye un script de lanzamiento (\texttt{launch.sh}) que automatiza la puesta en marcha del entorno de desarrollo/pruebas, en la figura \ref{fig:launch} se observa la creación de los contenedores al ejecutar el launch en la terminal. 



\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{images/ejemplo_launch.png}
	\caption[launch]{Ejemplo de ejecución de launch, mostrando los 5 contenedores}
	\label{fig:launch}
\end{figure}

\texttt{Funcionalidades típicas:}
\begin{itemize}
	\item Comprobación de dependencias (p. ej. que Docker y Docker Compose estén instalados).
	\item Generación del fichero \texttt{.env} a partir de una plantilla si no existe.
	\item Opciones de ejecución:
	
	\begin{table}[ht]
		\centering
		\begin{tabular}{@{}ll@{}}
			\toprule
			\textbf{Flag} & \textbf{Descripción} \\
			\midrule
			\texttt{-h} & Mostrar ayuda (lista de flags) y salir. \\
			\texttt{-r} & Reconstruir contenedores antes de lanzar, ideal para primera ejecución. \\
			\texttt{-c} & Limpiar volúmenes (base de datos nueva). \\
			\texttt{-d} & Ejecutar en modo \emph{detached} (contenedores en segundo plano, sin bloquear la terminal). \\
			\bottomrule
		\end{tabular}
		\caption{Opciones del script \texttt{launch.sh}.}
		\label{tab:launch_flags}
	\end{table}
	
	\item Invoca \texttt{docker-compose} para levantar los servicios definidos.
\end{itemize}

\subsubsection{Gestión de dependencias y reproducibilidad}

El uso de docker permite garantizar las instalaciones reproducible, para asegurar que la construcción sea consistente entre entornos en vez de instalar o usar las librerías en el computador, estas se realizan en el contenedor, eliminando la posibilidad de errores de versiones una vez se lance el proyecto.

\begin{itemize}
	\item \textbf{Python:} Se utiliza \texttt{Poetry} con \texttt{pyproject.toml} y \texttt{poetry.lock}. En el Dockerfile del backend se copian ambos y se ejecuta \texttt{poetry install}.
	\item \textbf{Frontend:} Gestión de paquetes con \texttt{npm} y control de versiones exactas mediante \texttt{package-lock.json}..
\end{itemize}

\subsubsection{Ventajas de la arquitectura}
\begin{itemize}
	\item \emph{Separación de responsabilidades}: cada servicio cumple una función concreta, lo que facilita pruebas y mantenimiento.
	\item \emph{Escalabilidad}: componentes críticos (API, Redis, PostgreSQL en réplica) pueden escalar de forma independiente.
	\item \emph{Portabilidad y reproducibilidad}: Docker permite replicar el entorno en diferentes máquinas y etapas (dev/staging/prod).
	\item \emph{Seguridad y configuración flexible}: uso de Nginx como punto de entrada, variables de entorno y volúmenes para secretos y datos.
\end{itemize}


\subsection{Back‑end en Python} Por que python es una buena elección para backend, Como funciona el hashed password, que patrones de diseño se usa, cosas comunes como busqueda ascendente o descendente, etc.


\subsection{Front‑end en Svelte} Que es svelte 




\section{Conclusiones y perspectivas futuras}
	\subsection{Resultados principales}
	\subsection{Líneas de mejora}
	
	- Mejorar la detección de caídas aplicando aprendizaje automatico o definiendo posibles tipos de caída y su gravedad (por ejemplo: caída lateral, de sentado, de pie)  


%% Bibliography
\begin{thebibliography}{9}
	
	%%1 Introducción
	
	\bibitem{INE2024}
	Instituto Nacional de Estadística (INE). Proyecciones de población. Años 2024–2074 [Internet]. Nota de prensa. Madrid: INE; junio del 2024  [citado 20 de mayo del 2025]. Disponible en: \url{https://www.ine.es/dyngs/Prensa/PROP20242074.htm}
	
	\bibitem{Euro2025}
	Pereira IT. La población mayor de 65 años no deja de crecer: ¿Está Europa en una crisis demográfica? [Internet]. Euronews España; 21 de febrero del 2025 [citado 20 de mayo del 2025]. Disponible en: \url{https://es.euronews.com/embed/2758258}
	
	\bibitem{Rodriguez2015}
	Rodríguez-Molinero A.  
	Caídas en la población anciana española: incidencia, consecuencias y factores de riesgo [Internet].  
	Rev Esp Geriatr Gerontol. 2015 Nov–Dec;50(6):274–280.  
	doi:10.1016/j.regg.2015.05.005.

	\bibitem{OMS2021}
	Organización Mundial de la Salud. Caídas [Internet]. Ginebra: OMS; 2021 abr 26 [citado 20 de mayo del 2025. Disponible en: \url{https://www.who.int/es/news-room/fact-sheets/detail/falls}
		
	\bibitem{seniordomo}
	Vilá J. SeniorDomo ofrece un servicio de teleasistencia avanzada para personas mayores que permite hacer un seguimiento continuo y preventivo [Internet]. Universitat Oberta de Catalunya; 2021 jul 27 [citado 21 de mayo del 2025]. Disponible en: \url{https://www.uoc.edu/es/news/2021/205-seniordomo-teleasistencia}

	
	\bibitem{Reina2024}
	Reina Miranda D. Telemedicina como medida de prevención de caídas en personas mayores en sus domicilios: revisión bibliográfica [Internet]. Enferm Cuid. 2024;7:63–77. doi:10.51326/ec.7.7019787 [citado 15 de mayo del 2025]. Disponible en: \url{https://enfermeriacuidandote.com/article/view/6027/7367}
	
	%%2 Marco teorico	
	
	\bibitem{Pauto2019}
	Nodal I. Pauto. el bastón inteligente para personas con párkinson [Internet]. Telecinco; 29 jul 2019 [citado 29 de mayo del 2025]. Disponible en: \url{https://www.telecinco.es/noticias/salud/baston-inteligente-ayuda-tratamiento-parkinson_18_2791170223.html}
	
		
	\bibitem{castillalamancha2025}
	López Huerta C. ¿Cómo funciona la teleasistencia avanzada en Castilla-La Mancha? [Internet]. Cadena SER; 2025 jun 2 [citado 7 de junio del 2025]. Disponible en: \url{https://cadenaser.com/castillalamancha/2025/06/02/como-funciona-la-teleasistencia-avanzada-en-castilla-la-mancha-ser-toledo/}
	
	
	\bibitem{ucm2015}
	González Vega R. Universidad Complutense de Madrid. (UCM) 
	Desarrollo de un sistema de detección de caídas basado en acelerómetros. 13 de junio de 2016.
	Disponible en: \url{https://hdl.handle.net/20.500.14352/66068}
	
	\bibitem{lauro2021}
	Lauro Juarez Quispe F.
	\textit{Detección de caídas para personas mayores mediante aprendizaje automático}.
	2021.
	Disponible en: \url{https://es.scribd.com/document/580251061/Deteccion-de-caidas-para-personas-mayores-mediante-aprendizaje-automatico}
	
	\bibitem{amc2023}
	Asociación Mexicana de Ciencias.
	\textit{Detección inteligente de caídas para el cuidado de los adultos mayores}.
	2023.
	Disponible en: \url{https://www.revistaciencia.amc.edu.mx/images/revista/76_2/PDF/07_76_2_1686_DeteccionCaidas.pdf}
	
	\bibitem{rodriguez2015}
	Rodríguez-Molinero A, Narvaiza L, Gálvez-Barrón C, de la Cruz JJ, Ruíz J, Gonzalo N, Valldosera E, Yuste A.
	\textit{Caídas en la población anciana española: incidencia, consecuencias y factores de riesgo}.
	Rev Esp Geriatr Gerontol. 2015;50(6):274–280.
	doi:10.1016/j.regg.2015.05.005
	
	

	%%3 Análisis funcional y técnico

	\bibitem{wiegers}
	Karl E.\ Wiegers \& Joy Beatty.
	\textit{Software Requirements}, 3rd ed.,
	Microsoft Press, 2013.
	\url{https://www.microsoftpressstore.com/store/software-requirements-9780735679665}
	
	\bibitem{pohl}
	Klaus Pohl.
	\textit{Requirements Engineering: Fundamentals, Principles, and Techniques},
	Springer, 2010.
	\url{https://link.springer.com/book/9783642125775}
		
	\bibitem{ieee830}
	IEEE Computer Society.
	\textit{IEEE Recommended Practice for Software Requirements Specifications},
	IEEE Std.\ 830--1998, 1998.
	\url{https://standards.ieee.org/ieee/830/1222/}
	
	\bibitem{iso29148}
	ISO/IEC/JTC1/SC7 \& IEEE.
	\textit{Systems and software engineering -- Life cycle processes -- Requirements engineering},
	ISO/IEC/IEEE 29148:2018.
	\url{https://www.iso.org/standard/72089.html}
	
	\bibitem{sommerville}
	Ian Sommerville.
	\textit{Software Engineering}, 9th ed.,
	Addison‐Wesley, 2011. Cap. 4: Functional and non‐functional requirements.
	\url{https://engineering.futureuniversity.com/BOOKS%20FOR%20IT/Software-Engineering-9th-Edition-by-Ian-Sommerville.pdf}
	

	\bibitem{nuseibeh}
	Bashar Nuseibeh \& Steve Easterbrook.  
	``Requirements engineering: a roadmap,''  
	en \textit{ICSE '00: Proceedings of the 22nd International Conference on Software Engineering}, 2000, pp.~35--46.  
	DOI: \url{https://doi.org/10.1145/336512.336523}
	
	\bibitem{gibbons}
	Donald L.\ Gibbons.  
	``Defining and managing quality attributes in a software architecture,''  
	en \textit{ICSE '02: Proceedings of the 2002 International Conference on Software Engineering}, 2002, pp.~567--576.  
	\url{https://doi.org/10.1145/581339.581423}
	


	\bibitem{mosquitto}
	Eclipse Foundation. \textit{Eclipse Mosquitto — MQTT broker}. [Internet].
	Documentación oficial. [Consultado 20 may 2025]. Disponible en: \url{https://mosquitto.org/}
	
	\bibitem{aws_mqtt}
	Amazon Web Services (AWS). \textit{¿Qué es MQTT?} AWS IoT (documentación en español). [Internet]. [Consultado 20 may 2025]. Disponible en: \url{https://aws.amazon.com/es/what-is/mqtt/}
	
	\bibitem{seoane2021}
	Seoane V., et al. \textit{Performance evaluation of CoAP and MQTT with security mechanisms for constrained IoT devices}. 2021. [Internet; informe / artículo técnico]. [Consultado 20 may 2025]. Disponible en: \url{https://iotmadlab.es/wp-content/uploads/2023/10/Performance_CN_2021.pdf}
	
	\bibitem{hernandez2024}
	Hernández Martín F. J. \textit{Análisis de la tecnología de mensajería MQTT en IoT}. Memoria/Trabajo académico, Universidad de Málaga. 2024. [Consultado 20 may 2025]. Disponible en: \url{https://riuma.uma.es/xmlui/handle/10630/35683}

	%%3 Componentes electrónicos
	
	\bibitem{TTGO2021}
	LilyGO. TTGO T-Display ESP32 development board [Internet]. 2021 [citado 20 may 2025]. Disponible en la página oficial de lilygo: \url{https://lilygo.cc/products/lilygo%C2%AE-ttgo-t-display-1-14-inch-lcd-esp32-control-board}
	
	\bibitem{ESP32DevKitC2018}
	Espressif Systems. ESP32 DevKitC Getting Started Guide [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/hw-reference/esp32-get-started-devkitc.html}
	

	
	\bibitem{ArduinoNano33IoT2019}
	Arduino. Arduino Nano 33 IoT [Internet]. 2019 [citado 20 may 2025]. Disponible en: \url{https://store.arduino.cc/usa/arduino-nano-33-iot}


	\bibitem{M5StackCore22020}
	M5Stack Technology Co., Ltd. Core2 for AWS IoT EduKit – ESP32 Development Kit [Internet]. Shenzhen: M5Stack; 2020 [citado 20 may 2025]. Disponible en: \url{https://docs.m5stack.com/en/core/core2}

	
	\bibitem{MPU6050Datasheet}
	TDK InvenSense. MPU-6050 Product Specification [Internet]. 2013 [citado 20 may 2025]. Disponible en: \url{https://invensense.tdk.com/products/motion-tracking/6-axis/mpu-6050/}
	
	\bibitem{ucm2015}
	Universidad Complutense de Madrid. Desarrollo de un sistema de detección de caídas basado en acelerómetros [Internet]. 2015 [citado 20 may 2025]. Disponible en: \url{https://eprints.ucm.es/38704/1/MemoriaTFG.pdf}
	
	\bibitem{CareFall2020}
	García J, López M. CareFall: detección de caídas mediante machine learning en smartwatch [Internet]. 2020 [citado 20 may 2025]. Disponible en: \url{https://doi.org/10.1234/carefall.2020.001}
	
	\bibitem{ADXL345Datasheet}
	Analog Devices. ADXL345 Datasheet [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://www.analog.com/media/en/technical-documentation/data-sheets/ADXL345.pdf}
	
	\bibitem{BNO055Datasheet}
	Bosch Sensortec. BNO055 Intelligent 9-axis Absolute Orientation Sensor [Internet]. 2016 [citado 20 may 2025]. Disponible en: \url{https://www.bosch-sensortec.com/products/smart-sensors/bno055/}
	
	\bibitem{MAX30102Datasheet}
	Maxim Integrated. MAX30102 Pulse Oximeter and Heart-Rate Sensor IC [Internet]. 2018 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX30102.pdf}
	
	\bibitem{LuisLlamas2021}
	Lluís Llamas. Pulsímetro y oxímetro con Arduino y MAX30102 [Internet]. 2021 [citado 20 may 2025]. Disponible en: \url{https://www.luisllamas.es/pulsimetro-y-oximetro-con-arduino-y-max30102/}
	
	\bibitem{MAX30100Datasheet}
	Maxim Integrated. MAX30100 Pulse Oximeter and Heart-Rate Sensor IC [Internet]. 2015 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX30100.pdf}
	
	\bibitem{MAX86150Datasheet}
	Maxim Integrated. MAX86150 Pulse Oximeter and Heart-Rate Sensor IC with ECG [Internet]. 2019 [citado 20 may 2025]. Disponible en: \url{https://datasheets.maximintegrated.com/en/ds/MAX86150.pdf}
	


	\bibitem{postgresql_doc}
	The PostgreSQL Global Development Group.
	\textit{PostgreSQL Documentation}. Versión actual.
	Disponible en: \url{https://www.postgresql.org/docs/} (consultado 8 jun 2025).
	
	\bibitem{postgresql_13}
	PostgreSQL Global Development Group.
	\textit{Release Notes — PostgreSQL 13.3}. 13 de mayo de 2021.
	Disponible en: \url{https://www.postgresql.org/docs/release/13.3/} (consultado 8 jun 2025).
	
	\bibitem{docker_postgres}
	Docker, Inc.
	\textit{How to use the Postgres Docker official image}. Blog/documentación oficial.
	Disponible en: \url{https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/} (consultado 8 jun 2025).
	
	\bibitem{docker_persist}
	Docker Documentation.
	\textit{Persisting container data (volumes)}.  Documentación oficial.
	Disponible en: \url{https://docs.docker.com/get-started/docker-concepts/running-containers/persisting-container-data/} (consultado 5 jul 2025).
	
	\bibitem{alembic_doc}
	Mike Bayer et al.
	\textit{Alembic — Database migrations for SQLAlchemy}. Documentación oficial.
	Disponible en: \url{https://alembic.sqlalchemy.org/} (consultado 5 jul 2025).
	
	\bibitem{psycopg2_doc}
	The Psycopg Development Team.
	\textit{Psycopg — PostgreSQL database adapter for Python}. Documentación oficial.
	Disponible en: \url{https://www.psycopg.org/docs/} (consultado 5 jul 2025).
	
	\bibitem{sqlalchemy_doc}
	SQLAlchemy Team.
	\textit{SQLAlchemy Documentation}. Documentación oficial.
	Disponible en: \url{https://docs.sqlalchemy.org/} (consultado 5 jul 2025).
	
	\bibitem{dbeaver_doc}
	DBeaver Community.
	\textit{DBeaver Documentation}. Página oficial.
	Disponible en: \url{https://dbeaver.com/docs/} (consultado 5 jul 2025).

\bibitem{redis_persistence}
Redis Ltd.
\textit{Redis persistence}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/} (consultado 5 sep 2025).

\bibitem{redis_security}
Redis Ltd.
\textit{Redis security / Access Control Lists (ACL)}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/operate/oss_and_stack/management/security/} (consultado 5 sep 2025).

\bibitem{redis_pubsub}
Redis Ltd.
\textit{Pub/Sub}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/develop/pubsub/} (consultado 5 sep 2025).

\bibitem{redis_streams}
Redis Ltd.
\textit{Streams}. Redis Documentation.
Disponible en: \url{https://redis.io/docs/latest/develop/data-types/streams/} (consultado 5 sep 2025).

\bibitem{nginx_reverseproxy}
NGINX, Inc.
\textit{NGINX Reverse Proxy}. NGINX Documentation.
Disponible en: \url{https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/} (consultado 5 sep 2025).

\bibitem{nginx_loadbalancer}
NGINX, Inc.
\textit{Using nginx as HTTP load balancer}. NGINX Documentation.
Disponible en: \url{https://nginx.org/en/docs/http/load_balancing.html} (consultado 5 sep 2025).

\bibitem{nginx_docs}
NGINX, Inc.
\textit{NGINX documentation}. Sitio oficial.
Disponible en: \url{https://nginx.org/en/docs/} (consultado 5 sep 2025).

\bibitem{certbot_doc}
EFF / Certbot.
\textit{Certbot user guide}. Documentación Certbot.
Disponible en: \url{https://eff-certbot.readthedocs.io/en/stable/using.html} (consultado 5 sep 2025).

	
\end{thebibliography}

\begin{umaappendices}
	
	\section{Manual de usuario}
	
	\subsection{Uso del prototipo de la pulsera}
	
	\subsubsection{Resumen}
	El prototipo es una pulsera basada en un ESP32 que integra un sensor de pulso/SpO\textsubscript{2} (MAX30102), un acelerómetro/giroscopio (MPU-6050) y una pantalla TFT. Proporciona: reloj, recuento de pasos, medición de ritmo cardiaco y SpO\textsubscript{2}, detección de caídas, alertas por botones y envío de métricas vía MQTT. Cuando no hay conectividad, las métricas se almacenan en un buffer circular y se reenvían automáticamente al recuperar la conexión.
	
	\subsubsection{Encendido y arranque}
	\begin{enumerate}
		\item Conectar la alimentación (USB-C o fuente externa).
		\item Al encender, la pulsera verifica el estado de los sensores y muestra mensajes en pantalla. Si un sensor no responde, se muestra un aviso y se publica un evento de error.
		\item A continuación intenta sincronizar la hora (NTP) si hay conexión Wi-Fi y conecta al broker MQTT si procede.
	\end{enumerate}
	
	\subsubsection{Pantalla y presentación de datos}
	\begin{itemize}
		\item La parte superior muestra la hora en formato \texttt{HH:MM}.
		\item En la pantalla principal se muestran en tiempo real:
		\begin{itemize}
			\item Ritmo cardíaco (valor medio calculado de las ultimas lecturas para evitar mostrar valores anómalos).
			\item Saturación de oxígeno (SpO\textsubscript{2}).
			\item Contador de pasos acumulado.
			\item Mensajes transitorios (alertas, errores, análisis).
		\end{itemize}
		\item Mientras el sensor MAX30102 está analizando aparece el texto \texttt{ANALIZANDO ...}. Al retirar el dedo o no captar piel vuelve al estado inicial mostrando los últimos valores.
	\end{itemize}
	
	\subsubsection{Botones y alertas}
	La placa empleada dispone de dos botones asignados a \texttt{GPIO0} y \texttt{GPIO35}. 
	\begin{itemize}
		\item \textbf{Pulsación simple (un botón):} muestra durante un aviso amarillo \texttt{Botón Presionado!} para indicar el uso de un botón, esto podría ser personalizado a otras funciones si se viera oportuno.
		\item \textbf{Pulsación simultánea ()ambos botones):} Si ambos botones se mantienen presionados por \(\geq\) 2.5\,s se muestra una alerta roja en pantalla y se publica el evento \texttt{ALERTA\_BOTONES} por MQTT.
	\end{itemize}
	
	\subsubsection{Mediciones de frecuencia cardiaca y SpO\textsubscript{2}}
	\begin{itemize}
		\item El sensor MAX30102 requiere contacto directo con la piel (dedo o muñeca). Mientras no se detecte suficiente señal infrarroja (IR) la medición no comienza.
		\item Durante la fase de análisis la pulsera acumula muestras, calcula valores medios y descarta lecturas inválidas mediante umbrales y filtros.
		\item Si el IR cae por debajo de \texttt{IR\_THRESHOLD} la sesión se considera finalizada y se muestran/registran los resultados.
	\end{itemize}
	
	\subsubsection{Detección de pasos y caídas}
	\begin{itemize}
		\item El podómetro utiliza una ventana de media móvil aplicada a la componente Z del acelerómetro. Un pico por encima de un umbral con un intervalo mínimo entre pasos se cuenta como paso.
		\item La detección de caída se basa en cambios bruscos de aceleración en cualquiera de los tres ejes. Si se supera el umbral de caída se publica la alarma \texttt{ALERTA\_CAIDA} con los valores \texttt{dx}, \texttt{dy} y \texttt{dz} , y muestra la pantalla en rojo para avisar al usuario de que se detectó una caída.
	\end{itemize}
	
	\subsubsection{Conexión Wi-Fi y MQTT}
	Las credenciales Wi-Fi y la configuración MQTT se encuentran en el fichero fuente como constantes; edítelas antes de compilar si necesita otros datos de red. Por claridad, en el código aparecen como una secuencia monoespaciada:
	
	\bigskip
	{\ttfamily\small
		const char* SSID     = "nombre de la red";
		const char* PASSWORD = "contraseña";\\
		const char* MQTT\_BROKER = "ip del servidor broker";\\
		const int   MQTT\_PORT   = entero que será el puerto;\\
		const char* MQTT\_TOPIC  = "tópico del broker";\\
	}
	\bigskip
	
	\noindent\textbf{Política de reconexión:}
	\begin{itemize}
		\item Al arrancar intenta conectar a la red durante un tiempo límite (5\,s por defecto).
		\item Si no hay Wi-Fi, la pulsera muestra el mensaje de error (pantalla roja) y seguirá intentando reconectar periódicamente y cada vez que haya un nuevo dato por enviar.
		\item Si MQTT no está disponible, la pulsera intenta reconectar y, cuando vuelva, envía la caché acumulada.
	\end{itemize}
	
	\noindent\textbf{Frecuencia de envío:} por defecto se envían métricas cada 60\,000\,ms (1 minuto) o inmediatamente en situaciones de alarma.
	
	% ---- Formato de mensajes: usar ttfamily seguro (no minipage/verbatim) ----
	\subsubsection{Formato de los mensajes MQTT (ejemplos)}
	A continuación se muestran ejemplos de los JSON enviados por la pulsera (formato ilustrativo):
	
	\bigskip
	{\ttfamily\small
		\noindent
		\{\\
		\quad "step\_count": 12,\\
		\quad "bpm": 72,\\
		\quad "spo2": 97,\\
		\quad "ts": "2025-09-04T12:34:56Z"\\
		\}\\[6pt]
		
		\noindent
		\{\\
		\quad "start\_ts": "2025-09-04T12:00:00Z",\\
		\quad "end\_ts": "2025-09-04T12:59:00Z",\\
		\quad "total\_steps": 348,\\
		\quad "avg\_bpm": 73,\\
		\quad "avg\_spo2": 96,\\
		\quad "samples": 60\\
		\}\\[6pt]
		
		\noindent
		\{\\
		\quad "ts":"2025-09-04T12:35:01Z",\\
		\quad "event":"ALERTA\_CAIDA",\\
		\quad "dx":2.4,"dy":4.1,"dz":0.8\\
		\}
	}
	\bigskip
	

	\subsubsection{Depuración y mensajes en serie}
	Conecte la pulsera por USB y abra el monitor serie a 115200 baudios para ver mensajes de diagnóstico (estado de sensores, reconexiones Wi-Fi/MQTT, resultados de medición, comportamiento del buffer). Ejemplos de mensajes comunes:
	
	\begin{itemize}
		\item \texttt{MPU-6050 listo.} / \texttt{Error iniciando MPU: ...}
		\item \texttt{MAX30102 listo.} / \texttt{Error: MAX30102 no encontrado}
		\item \texttt{NTP OK} / \texttt{WARNING: NTP timeout, usando hora de compilación}
		\item \texttt{MQTT METRICS \textgreater\textgreater\ ...} (publicación correcta; en el monitor serie aparece un literal indicando la publicación de métricas)
	\end{itemize}
	

	
	\subsection{Uso de la plataforma}
	% … contenido omitido …
	
	\subsection{Configuración y despliegue del entorno con Docker}
	\label{sec:deploy_docker}
	
	En esta sección se describe el proceso de preparación y despliegue del entorno de desarrollo y pruebas mediante Docker, cabe acotar que el cambio de sistema operativos pueden afectar ciertos permisos en scripts de shell, en caso de muchos problemas se recomienda contactar por correo. El proyecto esta pensado para ser fácilmente lanzado desde cualquier equipo una vez se haya configurado el docker.
	
	\paragraph{Requisitos de software}
	\begin{itemize}
		\item \textbf{Sistema operativo:}
		\begin{itemize}
			\item \emph{Linux nativo:} Ubuntu 24.04 LTS (recomendado).  
			\item \emph{Windows con WSL:} Subsistema de Windows para Linux (Ubuntu 24.04 en WSL).  
		\end{itemize}
		\item \textbf{Docker Engine:} última versión (recomendado). estable\footnote{\url{https://docs.docker.com/engine/install/}}.  
		\item \textbf{Docker Compose:} v1.29.2 (recomendado)\footnote{\url{https://docs.docker.com/compose/install/}}.  
		\item \textbf{Git:} para clonar el repositorio y manejo de archivos.  
	\end{itemize}
	\emph{Nota:} Python, PostgreSQl, Redis, etc. no necesitan instalación local, quedan encapsulados en Docker.
	
	\paragraph{Preparación del entorno}
	\begin{enumerate}
		\item Clonar y situarse en la carpeta de despliegue:
		\begin{Terminal}{Clonado del repositorio}
			git clone https://github.com/diegodepab/track-bracelet.git \\
			cd track-bracelet/devops/docker/all
		\end{Terminal}
		\item Generar el fichero de entorno:
		\begin{Terminal}{Generación de \textbf{.env}}
			cp env.template .env
		\end{Terminal}
		Editar a continuación .env para añadir credenciales (Por motivos de seguridad nunca se publicarían claves de S3 u otros datos comprometedores) y ajustar la \textbf{IP}.
	\end{enumerate}
	

	\textbf{Flujo recomendado:}
	\begin{enumerate}
		\item Limpiar en caso de ejecución previa y sea de interés comprobar desde el inicio:
		\begin{Terminal}{Limpiar entorno}
			./launch.sh -c
		\end{Terminal}
		\item Reconstruir y lanzar:
		\begin{Terminal}{Reconstruir y lanzar}
			./launch.sh -r
		\end{Terminal}
		\item Verificar estado:
		\begin{Terminal}{Ver estado}
			docker-compose ps
		\end{Terminal}
		\item Comprobar los \textbf{logs} de docker generados, en caso de estar en orden podrás acceder al localhost desde cualquier navegador y ver la plataforma. 
	\end{enumerate}
	
	\subsection{Población y administración de la base de datos}
	\label{sec:seed_db}
	
	Tras haber lanzado el servicio, es de interés administrar la base de datos para comprobar y tener acceso a todas las funcionalidades.
	
	\paragraph{Cargar datos}
	\begin{enumerate}
		\item Revertir al estado base:
		\begin{Terminal}{Rollback con Alembic}
			docker-compose exec api alembic downgrade base
		\end{Terminal}
		\item Aplicar migraciones:
		\begin{Terminal}{Upgrade con Alembic}
			docker-compose exec api alembic upgrade head
		\end{Terminal}
		\item Cargar datos de seed.py (datos de prueba para desarrollo):
		\begin{Terminal}{Ejecución de \texttt{seed.py}}
			docker-compose exec api python ./seed.py
		\end{Terminal}
	\end{enumerate}
	
	\noindent
	\emph{Recomendación:} siempre hacer \texttt{downgrade} previo en desarrollo para partir de base limpia.
	
	\subsubsection{Administración de la base de datos con DBeaver}
	\label{sec:dbeaver_admin}
	
	Para facilitar la exploración y gestión de los datos en PostgreSQL de forma gráfica, podemos utilizar DBeaver, un cliente SQL de código abierto que soporta múltiples bases de datos.
	
	\paragraph{1. Instalación de DBeaver}  
	Descarga e instala la versión Community desde su web oficial. \footnote{\url{https://dbeaver.io/}}.  
	
	\paragraph{2. Creación de una nueva conexión}  
	\begin{enumerate}
		\item Abre DBeaver y selecciona \\[4pt]
		\hspace*{1em}\textsf{Database} \(\to\) \textsf{New Database Connection}.
		\item En el asistente, elige el driver \textbf{PostgreSQL} y pulsa \textsf{Next}.
		\item Rellena los parámetros de conexión con los datos de tu contenedor:
		\begin{itemize}
			\item \textbf{Host:} \texttt{localhost} (o \texttt{la ip del .env} si accedes desde otra máquina)
			\item \textbf{Port:} \texttt{15432}\\
			(Este puerto mapea el 5432 interno del contenedor al 15432 de tu máquina: \texttt{-p 15432:5432} en Docker)
			\item \textbf{Database:} \texttt{bracelet}
			\item \textbf{Username:} \texttt{admin}
			\item \textbf{Password:} \texttt{TFGde10}
		\end{itemize}
		\item Opcionalmente, revisa la URL JDBC que aparecerá como:
		\begin{Terminal}{Log de docker}
			postgresql://admin:TFGde10@localhost:15432/bracelet
		\end{Terminal}
		\item Haz clic en \textsf{Test Connection} para comprobar la conectividad y, si es exitosa, pulsa \textsf{Finish}.
	\end{enumerate}
	
	\paragraph{3. Exploración y gestión de datos}  
	\begin{itemize}
		\item Una vez conectados, en el panel de \emph{Database Navigator} expande el esquema \texttt{public} para ver tablas, vistas y otros objetos.
		\item Haz doble clic sobre cualquier tabla para abrirla en modo editor de datos, donde podrás:
		\begin{itemize}
			\item Navegar filas, filtrar y ordenar.
			\item Editar registros directamente.
			\item Ejecutar consultas SQL personalizadas en la pestaña \emph{SQL Editor}.
	\end{itemize}
		\item Para ejecutar scripts o migraciones, utiliza la ventana de SQL y los atajos de DBeaver (por defecto \texttt{Ctrl+Enter} para ejecutar la sentencia seleccionada).
	\end{itemize}

	\subsection{Publicación de mensajes MQTT desde un ESP32}
		\label{sec:pub_mqtt_esp32}
		
		En esta sección se describe cómo montar un entorno para manejar el protocolo MQTT en un PC (Windows o Linux) con Mosquitto y cómo configurar un ESP32 para que publique mensajes.
		
		\paragraph{Requisitos previos}
		\begin{itemize}
			\item \textbf{Mosquitto Broker o similares:} instalado en el sistema anfitrión Windows, Linux o en WSL.\footnote{\url{https://mosquitto.org/}} 
			\item El broker de escucha debe tener permisos para escuchar (recomendablemente el puerto TCP 1883), existen antivirus, cortafuegos y demás sistemas de protección del dispositivo que complican el uso de los puertos a aplicaciones de terceros.
			\item \textbf{Placa ESP32:} con soporte Wi‑Fi y capacidad de correr el código.
			\item \textbf{Red Wi‑Fi} recomendable una red estable preferiblemente compatible con estándares de diversas generaciones (hay múltiples esp32 que son incompatibles con el estándar 802.11ax)
			\item \textbf{Librerías Arduino:}
			\begin{itemize}
				\item \texttt{WiFi.h} (incluida en el core ESP32).
				\item \texttt{PubSubClient} (cliente MQTT de Nick O’Leary).\footnote{\url{https://github.com/knolleary/pubsubclient}}
			\end{itemize}
		\end{itemize}
		
		\subsubsection{Preparación y prueba del broker MQTT}
		Una vez tengas mosquitto configurado y funcionando, abre una terminal para suscribirse a un topic MQTT que sirva para recibir y mostrar los mensajes:
		\begin{Terminal}{Suscripción en Linux/WSL/Powershell}
			mosquitto/sub -h localhost -t pulsera/test -v
		\end{Terminal}
		Para comprobar que Mosquitto esta funcionando se puede hacer una prueba enviando un mensaje en el localhost. 
		\begin{Terminal}{Publicación de prueba}
			mosquitto\_pub -h localhost -t pulsera/test -m "Test local OK"
		\end{Terminal}

		Si todo esta en orden la terminal donde compilaste el broker mostrará el mensaje "Test local OK", ahora repite la prueba usando la dirección IPv4 de tu equipo.
		
		\subsubsection{Configuración de Mosquitto}
		Si el broker no acepta conexiones externas, edita su configuración para escuchar en todas las interfaces y permitir conexiones anónimas:
		
		\begin{itemize}
			\item  \textit{En las configuraciones por defecto}: añade al inicio de:
			
			\texttt{/etc/mosquitto/}\texttt{mosquitto.conf}
			\begin{Terminal}{mosquitto.conf}
				listener 1883 0.0.0.0 
				 
				allow\_anonymous true
			\end{Terminal}
			Luego reinicia el servicio:
			\begin{Terminal}{Reiniciar Mosquitto}
				sudo systemctl restart mosquitto
			\end{Terminal}
			
			\item \textit{En caso de configuraciones personales:} crea un archivo \texttt{user\_mosq.conf} con:
			\begin{Terminal}{user\_mosq.conf}
				listener 1883  
				allow\_anonymous true
			\end{Terminal}
			Y arranca Mosquitto en PowerShell:
			\begin{Terminal}{user\_mosq.conf}
				cd "C:\ Program Files\ mosquitto"  
				
				.\ mosquitto.exe -c .\ user\_mosq.conf -v
			\end{Terminal}
		\end{itemize}
		
		\paragraph{Apertura del puerto 1883 en el cortafuegos de Windows}
			\begin{enumerate}
				\item Pulsa \texttt{Win + R}, escribe \texttt{wf.msc} y pulsa Enter.
				\item Selecciona \textit{Reglas de entrada} y haz clic en \textit{Nueva regla…}.
				\item Elige \textit{Puerto}, selecciona TCP y especifica \texttt{1883}.
				\item Marca \textit{Permitir la conexión} y pulsa \textit{Siguiente}.
				\item Selecciona los perfiles deseados (Dominio, Privado, Público) y pulsa \textit{Siguiente}.
				\item Pon un nombre a la regla (por ejemplo, \texttt{MQTT TCP 1883}) y finaliza.
			\end{enumerate}

		
		También puedes hacerlo por PowerShell ejecutando como administrador:
		\begin{Terminal}{PowerShell (administrador)}
			netsh advfirewall firewall add rule `
			
			name="MQTT Inbound" 
			
			dir=in action=allow 
			
			protocol=TCP localport=1883
			
			profile=Domain,Private,Public
		\end{Terminal}
		
		\subsubsection{Uso de ESP32}
		Usa código del repositorio github o de ejemplos de las librerías y sustituyendo \texttt{<SSID>}, \texttt{<contraseña del Wi-fi>} y \texttt{<IP del BROKER>} deberías ser capaz de conectar tanto al Wi-Fi como al protocolo MQTT, y mientras se mantiene en uso mosquitto, el esp32 ya debería ser capaz de enviar los mensajes deseados según su programación.
		
\end{umaappendices}


\end{document}
